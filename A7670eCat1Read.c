/**********************************************************************************************************************
 * \file A7670eCat1.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "A7670eCat1Read.h"
#include "Bsp.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RX &IfxAsclin3_RXC_P20_3_IN
#define TX &IfxAsclin3_TX_P20_0_OUT
#define WAIT_TIME 1000

typedef struct
{
        uint8 MemoryName[3];
        uint16 messagesNo;
}LTEmessageMem;

typedef struct
{
        uint8 MessageNumber[30];
        uint8 Message[50];

}ReadMessage;

uint16 LteReadNoMesTi = 0;
uint16 LteReadMesTi = 0;

LTEmessageMem LteMem;
eStateLTEmon LTEstate = EnIdle;

eStateGetMsgMon ReadMsgstate = enChMsgNo;
ReadMessage LastReadMsg;

eStateMsgNo MsgNoState = enMsgNoSend;
eStateGetUserMsg UserReadMsg = enGetMsgIndex;
eStateReadMsg estateReadMsg = enStartRead;
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
Ifx_TickTime ticksFor1s;
uint8* LTEReadMsg; /* To be clarified the return messages */

uint8 A7670eCatReadCmd[50];

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static inline void vDoChkAtOk(void);
static inline void vDoReadMsg(void);
static inline void vDoChkMsgNo(void);
static inline void StoreMemoryName(void);
static inline void StoreMessageNumber(void);
static inline void vDoStorePhoneNumber(void);
void PrintUartMessage(void);
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void Set_A7670eCatReadCmd(uint8* command,Ifx_SizeT length)
{
    for(Ifx_SizeT i=0;i<length;i++)
    {
        A7670eCatReadCmd[i] = command[i];
    }
}

Ifx_SizeT Get_LenA7670eCatReadCmd(void)
{
    Ifx_SizeT length = 0;
    for(Ifx_SizeT i=0;i<sizeof(A7670eCatReadCmd);i++)
    {
        if(A7670eCatReadCmd[i]=='\0')
        {
            return length;
        }
        else
        {
            length++;
        }
    }
    return length;
}

void vDoRstLteRead(void)
{
    ReadMsgstate = enChMsgNo;
    UserReadMsg = enGetMsgIndex;
    estateReadMsg = enStartRead;
    LteReadNoMesTi = 0;
    LteReadMesTi = 0;
}

void vDoRunReadMessage(void)
{
    uint8 twoBytes[2] = {'O','K'};
    Ifx_SizeT twoByteslen = sizeof(twoBytes);
    uint8 startString[2] = {'+','C'};
    uint8 startNumber[2] = {',','"'};
    uint8 MessageDeleted[] = "\r\nMessage has been deleted";
    uint8 endChar = 10;
    Ifx_SizeT commandLength = 0;
    boolean StringCmp = FALSE;
    switch(estateReadMsg)
    {
        case enStartRead:
            SerialReadString(2);
            for(Ifx_SizeT i=0;i<sizeof(LastReadMsg.MessageNumber);i++)
            {
                LastReadMsg.MessageNumber[i] = '\0';
            }
            for(Ifx_SizeT i=0;i<sizeof(LastReadMsg.Message);i++)
            {
            LastReadMsg.Message[i] = '\0';
            }
            StringCmp = SerialCmpString(twoBytes,twoByteslen);
            if(StringCmp)
            {
                UartWriteln(MessageDeleted,sizeof(MessageDeleted));
                estateReadMsg = enEnd;
            }
            else
            {
                estateReadMsg = enMessageExists;
            }
            break;

        case enMessageExists:
            StringCmp = SerialCmpString(startString,sizeof(startString));
            if(StringCmp)
            {
                estateReadMsg = enGetNumber;
                SerialReadChar();
            }
            else
            {
                estateReadMsg = enFail;
            }
            break;

        case enGetNumber:
            StringCmp = SerialCmpString(&startNumber[0],1);
            if(StringCmp)
            {
                SerialReadChar();
                StringCmp = SerialCmpString(&startNumber[1],1);
                if(StringCmp)
                {
                    vDoStorePhoneNumber();
                    estateReadMsg = enGetMessage;
                }
                else
                {
                }
            }
            else
            {
                SerialReadChar();
            }
            break;

        case enGetMessage:
            SerialremoveReadFifo();
            for(Ifx_SizeT i=0;i<sizeof(LastReadMsg.Message);i++)
            {
                SerialReadChar();
                StringCmp = SerialCmpString(&endChar,1);
                if(StringCmp)
                {
                    i=sizeof(LastReadMsg.Message)-1;
                    estateReadMsg = enEnd;
                }
                else
                {
                    LastReadMsg.Message[i] = Get_readBuf(0);
                }
            }
            break;

        case enEnd:
            PrintUartMessage();
            vDoRstLteRead();
            wait(ticksFor1s);
            LTEstate = enEndRead;
            break;
            /* Finish message */

        case enFail:
            SerialremoveReadFifo();
            estateReadMsg = enStartRead;
            break;

        default:
            break;
    }
    if(LteReadMesTi==2000)
    {
        LteReadMesTi = 0;
        commandLength = Get_LenA7670eCatReadCmd();
        SerialWritenl(A7670eCatReadCmd,commandLength);
        estateReadMsg = enStartRead;
    }
    else
    {
        LteReadMesTi++;
    }

}
uint16 convNumberCharsInt(uint8 *charArray)
{
    uint8 uint8char = '0';
    return (10*((uint16)(charArray[0]-uint8char))+(uint16)(charArray[1]-uint8char));
}
uint16 ConvArCharsInt(uint8 *charArray)
{
    uint16 IntArCharVal=0;
    uint8 numberOfDigits = 0;
    for(Ifx_SizeT i=0;i<4;i++)
    {
        if(charArray[i]=='e')
        {
            /*Response Ended*/
        }
        else
        {
            numberOfDigits+=1;
        }
    }

    if(numberOfDigits==1)
    {
        return ((uint16)(charArray[0]));
    }
    else if(numberOfDigits==2)
    {
        IntArCharVal = 10*(uint16)(charArray[0])+(uint16)(charArray[1]);
        return IntArCharVal;
    }
    else if(numberOfDigits==3)
    {
        IntArCharVal = 100*(uint16)(charArray[0])+10*(uint16)(charArray[1])+(uint16)(charArray[2]);
        return IntArCharVal;
    }
    else if(numberOfDigits==4)
    {
        IntArCharVal = 1000*(uint16)(charArray[0])+100*(uint16)(charArray[1])+10*(uint16)(charArray[2])+(uint16)(charArray[3]);
        return IntArCharVal;
    }
    else
    {
        return 0;
    }
}

void PrinUartMessageNumbers(void)
{
    uint8 StartingReadState[] = "Write the index of the message you want to read: ";
    uint8 MemoryName[] = "Memory Name: ";
    Ifx_SizeT MemoNameLen = sizeof(MemoryName);
    uint8 Numbers[] = " Numbers: ";
    Ifx_SizeT NumbersLen = sizeof(Numbers);
    uint8 messageNo[3];
    messageNo[1] =(uint8)(LteMem.messagesNo & 0xFF);
    messageNo[1] += '0';
    messageNo[0] =(uint8) ((LteMem.messagesNo >> 8) & 0xFF);
    messageNo[0] += '0';
    UartWriteWord(MemoryName,MemoNameLen);
    UartWriteWord(LteMem.MemoryName, sizeof(LteMem.MemoryName));
    UartWriteWord(Numbers,NumbersLen);
    UartWriteln(messageNo,sizeof(messageNo));
    UartWriteWord(StartingReadState,sizeof(StartingReadState));
}

void PrintUartMessage(void)
{
    uint8 StartingReadState[] = "User with number ";
    uint8 Said[] = " said:";
    uint8 endLine[] = "\r\n";

    UartWriteWord(endLine,sizeof(endLine));
    UartWriteWord(StartingReadState,sizeof(StartingReadState));
    for(Ifx_SizeT i=0;i<sizeof(LastReadMsg.MessageNumber);i++)
    {
        if(LastReadMsg.MessageNumber[i]=='\0')
        {
            break;
        }
        else
        {
            UartWriteWord(&LastReadMsg.MessageNumber[i],1);
        }
    }
    UartWriteWord(Said,sizeof(Said));
    for(Ifx_SizeT i=0;i<sizeof(LastReadMsg.MessageNumber);i++)
    {
        if(LastReadMsg.Message[i]=='\0')
        {
            break;
        }
        else
        {
            UartWriteWord(&LastReadMsg.Message[i],1);
        }
    }
    UartWriteWord(endLine,sizeof(endLine));
}

static inline void setTicksFor1s(void)
{
    ticksFor1s = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);
}

/* Initialize the LTE serial interface and USB serial interface */
void InitLTE(void)
{
    setTicksFor1s();
    UartInit(RX,TX,115200);
    InitSerialInterface();
}

/* Main LTE running function */
void vDoReadLTE(void)
{
    switch(LTEstate)
    {
        case EnIdle:
            vDoChkAtOk(); /* Run the operation of LTE check function */
            break;

        case EnGetMsg:
            vDoReadMsg();  /* run the reading messages function */
            break;

        case enEndRead:
            break;
        default:
            LTEstate = EnIdle;
            break;
    }
}

/* Check if the LTE works properly */
static inline void vDoChkAtOk(void)
{
    uint8 AtMessage[] = "AT";
    Ifx_SizeT Atlen = sizeof(AtMessage);
    uint8 AtResponse[] = "OK";
    Ifx_SizeT AtResponselen = sizeof(AtResponse);
    boolean AtResponseOK;

    SerialWritenl(AtMessage,Atlen); /* Send message AT*/

    SerialReadnl(AtResponselen);   /* Read message with the length of OK as expected response*/
    AtResponseOK = SerialCmpNl(AtResponse,AtResponselen); /* Compare message with the length of total response */
    if(AtResponseOK)
    {
        SerialremoveReadFifo();
        LTEstate = EnGetMsg;  /* Move to reading messages state */
    }
    else
    {
        /* In case the return message is ERROR or the same write message do not do anything */
    }
}

/* Function to store the message numbers and the memory name */
static inline void vDoChkMsgNo(void)
{
    uint8 ReadMsgCmd[] = "AT+CMGR=";
    Ifx_SizeT ReadMsglen = sizeof(ReadMsgCmd);
    uint8 ReadMessageNo[] = "AT+CPMS?";
    Ifx_SizeT Atlen = sizeof(ReadMessageNo);
    uint8 testChar = '+';
    switch(MsgNoState)
    {
        /* first state we send the AT command to get the number of messages and memory number */
        case enMsgNoSend:
            SerialWritenl(ReadMessageNo,Atlen);
            MsgNoState = enMsgNoStart;
            break;
        /* We wait for the first correct response of A7670 */
        case enMsgNoStart:
            SerialReadChar();
            if (charCmp(testChar))
            {
                MsgNoState = enMsgNoName;
            }
            else
            {
                /* Prepare to read the next char */
            }
            break;
        /* We wait for start reading the name of the memory of the sim card */
        case enMsgNoName:
            testChar = '"';
            SerialReadChar();
            if (charCmp(testChar))
            {
                MsgNoState = enMsgNoNameStart;
            }
            else
            {
                /* Prepare to read the next char */
            }
            break;
        /* Read the memory name */
        case enMsgNoNameStart:
            StoreMemoryName();
            break;
        /* Read to start saving the messages number */
        case enMsgNoNumber:
            testChar = ',';
            SerialReadChar();
            if (charCmp(testChar))
            {
                MsgNoState = enMsgNoNumberStart;
            }
            else
            {
                /* Prepare to read the next char */
            }
            break;
        /* Read Messages */
        case enMsgNoNumberStart:
            StoreMessageNumber(); /* Store the message number to struct function */
            break;

        /* Send messages to uart and move to next state */
        case enMsgNoFinish:
            PrinUartMessageNumbers();
            Set_A7670eCatReadCmd(ReadMsgCmd,ReadMsglen);
            SerialremoveReadFifo();
            ReadMsgstate = enGetUserMsg;
            break;
        default:
            break;
    }
    LteReadNoMesTi++;
    if (LteReadNoMesTi==1000)
    {
        LteReadNoMesTi = 0;
        MsgNoState = enMsgNoSend; /* Restart Test */
    }
    else
    {
        /* Keep running */
    }
}

/* Function to Get specific message give by user */

static inline void vDoReadUserMsg(void)
{
    uint8 ReadMsgLen = 8;
    uint8 UserNumber[2];
    uint8 WrongMessage[] = "Invalid index. Try Again: ";
    uint8 NewLine[] = "\r\n";
    uint16 realMsgIndex = 0;
    switch(UserReadMsg)
    {
        case enGetMsgIndex:
            receive_data(2);
            UserNumber[0] = Get_UsbRxBufferIndex(0);
            UserNumber[1] = Get_UsbRxBufferIndex(1);
            realMsgIndex = convNumberCharsInt(UserNumber);
            if((realMsgIndex>0) && (realMsgIndex<=LteMem.messagesNo))
            {
                UserReadMsg = enSendMsgIndex;
            }
            else
            {
                /* Print to the user that he wrote wrong index */
               UartWriteWord(NewLine,sizeof(NewLine));
               UartWriteWord(WrongMessage,sizeof(WrongMessage));
            }
            break;
        case enSendMsgIndex:
            if(Get_UsbRxBufferIndex(0)=='0')
            {
                A7670eCatReadCmd[ReadMsgLen]=Get_UsbRxBufferIndex(1);
                A7670eCatReadCmd[ReadMsgLen+1]='\0';
                ReadMsgLen+=2;

            }
            else
            {
                A7670eCatReadCmd[ReadMsgLen]=Get_UsbRxBufferIndex(0);
                A7670eCatReadCmd[ReadMsgLen+1]=Get_UsbRxBufferIndex(1);
                A7670eCatReadCmd[ReadMsgLen+2]='\0';
                ReadMsgLen+=3;
            }
            UserReadMsg=enCheckMsgValid;

            SerialWritenl(A7670eCatReadCmd,ReadMsgLen);
            break;
        case enCheckMsgValid:
            vDoRunReadMessage();
            break;
        default:
            break;
    }
}

/* Main Function to Read messages
 * At first we run the function where we check the number of messages and the memory name
 * At second we store every message and the user's number
 * At the end we let the user using the uart to read any message he wants and
 * Then we are on stanby where we wait for new messages to come
 */
static inline void vDoReadMsg(void)
{
    switch(ReadMsgstate)
    {
        case enChMsgNo:
            vDoChkMsgNo(); /* check messages number function */
            break;
        case enGetUserMsg:
            vDoReadUserMsg();
            break;
        default:
            ReadMsgstate = enChMsgNo;
            break;
    }
}

static inline void StoreMemoryName(void)
{
    uint8 finishChar = '"';
    for (Ifx_SizeT i=0;i<sizeof(LteMem.MemoryName);i++)
    {
        SerialReadChar();
        if (charCmp(finishChar))
            {
                MsgNoState = enMsgNoNumber;
                break;
            }
            else
            {
                /* Store the Reading Char to our memory structure */
                LteMem.MemoryName[i] = Get_readBuf(0);

            }
    }
}

static inline void StoreMessageNumber(void)
{
   uint8 MessageNoChar[4] = {'e','e','e','e'};
   uint8 finishChar = ',';
   SerialReadChar();
   for (Ifx_SizeT i=0;i<sizeof(MessageNoChar);i++)
   {
       if (charCmp(finishChar))
       {
           MsgNoState = enMsgNoFinish;
           break;
       }       /* Store the Reading Char to our memory structure */
       else
       {
           MessageNoChar[i] = (Get_readBuf(0)-'0');
           SerialReadChar();
       }
   }
   LteMem.messagesNo=ConvArCharsInt(MessageNoChar);
}

static inline void vDoStorePhoneNumber(void)
{
    uint8 finishChar = '"';
    for(Ifx_SizeT i=0;i<sizeof(LastReadMsg.MessageNumber);i++)
    {
            SerialReadChar();
            if(charCmp(finishChar))
            {
                estateReadMsg = enGetMessage;
                LastReadMsg.MessageNumber[i] = '\0';
                break;
            }
            else
            {
                LastReadMsg.MessageNumber[i] = Get_readBuf(0);
            }
    }
}

