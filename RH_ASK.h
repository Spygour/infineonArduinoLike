/**********************************************************************************************************************
 * \file RH_ASK.h
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#ifndef RH_ASK_H_
#define RH_ASK_H_

#include <string.h>
#include "Bsp.h"
#include <stdlib.h>
#include "Ifx_Types.h"
#include "pinsReadWrite.h"
#include "INTERRUPTS.h"
#include "IfxStm.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
// This is the address that indicates a broadcast
#define RH_BROADCAST_ADDRESS 0xff
// Maximum message length (including the headers, byte count and FCS) we are willing to support
// This is pretty arbitrary
#define RH_ASK_MAX_PAYLOAD_LEN 67

// The length of the headers we add (To, From, Id, Flags)
// The headers are inside the payload and are therefore protected by the FCS
#define RH_ASK_HEADER_LEN 4

// This is the maximum message length that can be supported by this library.
// Can be pre-defined to a smaller size (to save SRAM) prior to including this header
// Here we allow for 1 byte message length, 4 bytes headers, user data and 2 bytes of FCS
#define RH_ASK_MAX_MESSAGE_LEN (RH_ASK_MAX_PAYLOAD_LEN - RH_ASK_HEADER_LEN - 3)

// The size of the receiver ramp. Ramp wraps modulo this number
#define RH_ASK_RX_RAMP_LEN 160

// Number of samples per bit
#define RH_ASK_RX_SAMPLES_PER_BIT 8

// Internal ramp adjustment parameter
#define RH_ASK_RAMP_INC (RH_ASK_RX_RAMP_LEN/RH_ASK_RX_SAMPLES_PER_BIT)

// Internal ramp adjustment parameter
#define RH_ASK_RAMP_TRANSITION RH_ASK_RX_RAMP_LEN/2

// Internal ramp adjustment parameter
#define RH_ASK_RAMP_ADJUST 9

// Internal ramp adjustment parameter
#define RH_ASK_RAMP_INC_RETARD (RH_ASK_RAMP_INC-RH_ASK_RAMP_ADJUST)

// Internal ramp adjustment parameter
#define RH_ASK_RAMP_INC_ADVANCE (RH_ASK_RAMP_INC+RH_ASK_RAMP_ADJUST)

// This is the number of 6 bit nibbles in the preamble
#define RH_ASK_PREAMBLE_LEN 8

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
 typedef enum
    {
    RHModeInitialising = 0, ///< Transport is initializing. Initial default value until init() is called..
    RHModeSleep,            ///< Transport hardware is in low power sleep mode (if supported)
    RHModeIdle,             ///< Transport is idle.
    RHModeTx,               ///< Transport is in the process of transmitting a message.
    RHModeRx,               ///< Transport is in the process of receiving a message.
    RHModeCad               ///< Transport is in the process of detecting channel activity (if supported)
    } RHMode;

typedef struct
{
    volatile RHMode    _mode;
    uint8             _thisAddress;
    boolean           _promiscuous;
    volatile uint8    _rxHeaderTo;
    volatile uint8    _rxHeaderFrom;
    volatile uint8    _rxHeaderId;
    volatile uint8    _rxHeaderFlags;
    uint8             _txHeaderTo;
    uint8             _txHeaderFrom;
    uint8             _txHeaderId;
    uint8             _txHeaderFlags;
    volatile uint16   _rxBad;
    volatile uint16   _rxGood;
    volatile uint16   _txGood;
    volatile boolean  _cad;
    unsigned int      _cad_timeout;
} RHGenericDriver;

typedef struct
{
    RHGenericDriver RHGeneric;
    float32        speed;
    Ifx_P*       rxPinPort;
    uint8         rxPinIndex;
    Ifx_P*       txPinPort;
    uint8         txPinIndex;
    Ifx_P*       pttPinPort;
    uint8         pttPinIndex;
    boolean       pttInverted;
} RH_ASK;
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/


// True of the sense of the rxPin is to be inverted
extern boolean  _rxInverted;

// Buff is filled but not validated
extern volatile boolean   _rxBufFull;

// Buff is full and valid
extern volatile boolean   _rxBufValid;

// Last digital input from the Rx data pin
extern volatile boolean   _rxLastSample;

// This is the integrate and dump integral. If there are <5 0 samples in the PLL cycle
// the bit is declared a 0, else a 1
extern volatile uint8 _rxIntegrator;

// PLL ramp, varies between 0 and RH_ASK_RX_RAMP_LEN-1 (159) over
// RH_ASK_RX_SAMPLES_PER_BIT (8) samples per nominal bit time.
// When the PLL is synchronized, bit transitions happen at about the
// 0 mark.
extern volatile uint8 _rxPllRamp;

// Flag indicates if we have seen the start symbol of a new message and are
// in the processes of reading and decoding it
extern volatile uint8 _rxActive;

// Last 12 bits received, so we can look for the start symbol
extern volatile uint16 _rxBits;

// How many bits of message we have received. Ranges from 0 to 12
extern volatile uint8 _rxBitCount;

// The incoming message buffer
extern uint8 _rxBuf[RH_ASK_MAX_PAYLOAD_LEN];

// The incoming message expected length
extern volatile uint8 _rxCount;

// The incoming message buffer length received so far
extern volatile uint8 _rxBufLen;

// Index of the next symbol to send. Ranges from 0 to vw_tx_len
extern uint8 _txIndex;

// Bit number of next bit to send
extern uint8 _txBit;

 // Sample number for the transmitter. Runs 0 to 7 during one bit interval
extern uint8 _txSample;

// The transmitter buffer in _symbols_ not data actuates
extern uint8 _txBuf[(RH_ASK_MAX_PAYLOAD_LEN * 2) + RH_ASK_PREAMBLE_LEN];

// Number of symbols in _txBuf to be sent;
extern uint8 _txBufLen;





/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
boolean RHGenericDriver_Init();
boolean RH_ASK_Init(float32 speed,Ifx_P* rxPort ,uint8 rxPin,Ifx_P* txPort, uint8 txPin,Ifx_P* pttPort, uint8 pttPin, boolean pttInverted);
boolean waitPacketSent();
boolean readRx();
void writePtt(boolean value);
void writeTx(boolean value);
void setModeIdle();
void setModeRx();
void setModeTx();
uint8 timerCalc(float32 speed,uint16 max_ticks, float32 *nticks);
void timerSetup();
boolean available();
boolean recv(uint8* buf, uint8* len);
uint16 RHcrc_ccitt_update (uint16 crc, uint8 data);
boolean isChannelActive();
boolean waitCAD();
boolean send(const uint8* data, uint8 len);
uint8 symbol_6to4(uint8 symbol);
void validateRxBuf();
void receiveTimer();
void transmitTimer();
void handleTimerInterrupt();

#endif /* RH_ASK_H_ */
