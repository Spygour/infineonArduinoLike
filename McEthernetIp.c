/**********************************************************************************************************************
 * \file McEthernetIp.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "McEthernetIp.h"
#include "McEthernetPacket.h"
#include "Dma.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define MCETHIP_DATASIZE     128
#define MCETHIP_HEADER_LEN   20
#define MCETHIP_ADDRESS_SIZE 4
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint16 McEthIp_TransmitTcpChecksum;
uint8 McEthIp_TransmitBuffer[MCETHIP_DATASIZE];

MCETH_IP_NODE McEthIp_IpNode = {
    McEthIp_TransmitBuffer,
    MCETHIP_DATASIZE,
    NULL_PTR
};


static uint8 MCETHIP_TxSrcIpAddress[MCETHIP_ADDRESS_SIZE] = {0, 0, 0, 0};
static uint8 McEthIp_TxDstIpAddress[MCETHIP_ADDRESS_SIZE] = {0, 0, 0, 0};
static MCETHIP_IP McEth_TxIpAddress = {
    MCETHIP_TxSrcIpAddress,
    McEthIp_TxDstIpAddress
};

static MCETH_IPHEADER McEth_TxIpHeader = {
    0x45,
    0x00,
    0,
    0,
    0x4000,
    0x40,
    0x06,
    0,
    &McEth_TxIpAddress
};

static MCETH_TCPHEADER McEth_TxTcpHeader = {
    0x8795,
    0x01BB,
    0x00000001,
    0x00000001,
    0x50,
    0x18,
    0xFFFF,
    0x0,
    0x0,
    0x0
};

MCETH_HEADER McEthIp_TxHeader = {
    &McEth_TxIpHeader,
    &McEth_TxTcpHeader
};

uint8 McEthIp_TcpHeader[MCETHIP_HEADER_LEN];

MCETH_IP_TRANSMIT_STATE McEthIp_TransmitState = ETH_TRANSMIT_IDLE;
MCETH_IP_RECEIVE_STATE McEthIp_ReceiveState = ETH_RECEIVE_IDLE;

IfxDma_Dma_Channel McEthiIp_DmaPachetHandler;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static inline void McEthUpdateIpCheckSum(uint8* IpHeader);
static inline void McEthUpdateTcpCheckSum(uint8* BytesArray, uint16 size);
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/


/** \brief Initializes the Ethernet Module
 * This Initializes the Ethernet Module
 * \param McEthIp_Init
 * \return void
 */
void McEthIp_Init(uint8* MacAddress)
{
  McEthiIp_DmaPachetHandler.channelId = IfxDma_ChannelId_0;

  /* Initialize the Source and Destination to be the same  then it will change in the next transaction */
  Dma_Init(&McEthiIp_DmaPachetHandler, 128, (uint32)(&McEthIp_TransmitBuffer[0]), (uint32)(&McEthIp_TransmitBuffer[0]));
  McEth_Init(MacAddress);
}



/** \brief Creates the Ip Header that needs to be send to the buffer
 * \param McEth_CreateIpHeader
 * \return void
 */
static void McEth_CreateIpHeader(MCETHIP_IP* IpAddress, uint16 PayloadSize)
{
  static uint8 McEthIp_IpHeader[20];
  uint16 MessageLength = 14 + 2*MCETHIP_HEADER_LEN + PayloadSize;
  /* Type is Ipv4 for now */
  McEthIp_IpHeader[0] = McEthIp_TxHeader.IpHeader->Version_HeaderLength;
  /* Type of service is 0 */
  McEthIp_IpHeader[1] = McEthIp_TxHeader.IpHeader->DifferecialServices;
  /* Total Length */
  McEthIp_IpHeader[2] = (uint8)(MessageLength >> 8);
  McEthIp_IpHeader[3] = (uint8)(MessageLength & 0x00FF);
  McEthIp_TxHeader.IpHeader->TotalLength = MessageLength;
  /* Identification */
  McEthIp_IpHeader[4] = (uint8)(McEthIp_TxHeader.IpHeader->Identification >> 8);
  McEthIp_IpHeader[5] = (uint8)(McEthIp_TxHeader.IpHeader->Identification & 0x00FF);
  /* Fragment Deactivated */
  McEthIp_IpHeader[6] = (uint8)(McEthIp_TxHeader.IpHeader->FragmentOffset >> 8);
  McEthIp_IpHeader[7] = (uint8)(McEthIp_TxHeader.IpHeader->FragmentOffset & 0x00FF);
  /* TTL in case we speak with router */
  McEthIp_IpHeader[8] = McEthIp_TxHeader.IpHeader->TimeToLive;
  /* TCP protocol for now */
  McEthIp_IpHeader[9] = McEthIp_TxHeader.IpHeader->Protocol;
  /* Header Checksum 0 after the initialization will be updated */
  McEthIp_IpHeader[10] = 0x00;
  McEthIp_IpHeader[11] = 0x00;
  /* Store the SrcAddress */
  for (uint8 i = 0; i < 4; i++)
  {
    McEthIp_IpHeader[12 + i] = IpAddress->McEthIp_SrcAddress[i];
    McEthIp_TxHeader.IpHeader->SrcDstIpAddress->McEthIp_SrcAddress[i] = IpAddress->McEthIp_SrcAddress[i];
  }
  /* Store the DstAddress */
  for (uint8 i = 0; i < 4; i++)
  {
    McEthIp_IpHeader[16 + i] = IpAddress->McEthIp_DstAddress[i];
    McEthIp_TxHeader.IpHeader->SrcDstIpAddress->McEthIp_DstAddress[i] = IpAddress->McEthIp_DstAddress[i];
  }

  McEthUpdateIpCheckSum(McEthIp_IpHeader);
  McEthIp_TxHeader.IpHeader->CheckSum = (uint16)((McEthIp_IpHeader[10] << 8) | (McEthIp_IpHeader[11]));
  McEthIp_TxHeader.IpHeader->Identification = (McEthIp_TxHeader.IpHeader->Identification == 0xFFFF) ? 1 : McEthIp_TxHeader.IpHeader->Identification+1;
  if (McEth_PushTransmitMessage(McEthIp_IpHeader, MCETHIP_HEADER_LEN))
  {
    /* Ok */
  }
  else
  {
    /* Buffer is full */
  }
}



/** \brief Initializes the TCP header for transmit the TCP packet
 * \param McEth_CreateTcpHeader
 * \return void
 */
static void McEth_CreateTcpHeader(uint16 PayloadSize)
{
  /* Message will be pushed with checksum of tcp for now Write value of CheckSum will be stored for future use */
  McEthIp_TxHeader.TcpHeader->Aknowledgment = McEthIp_TxHeader.TcpHeader->SeqNumber + PayloadSize;
  /* This variable needs to be stored in order to update the checksum correctly */
  McEthIp_TransmitTcpChecksum = McEth_WriteAddress + 17;
  static uint8 McEthIp_TcpHeader[20];
  /* Source Port 2 bytes */
  McEthIp_TcpHeader[0] = (uint8)(McEthIp_TxHeader.TcpHeader->SrcPort >> 8);
  McEthIp_TcpHeader[1] = (uint8)(McEthIp_TxHeader.TcpHeader->SrcPort & 0x00FF);
  /* Destination Port 2 bytes */
  McEthIp_TcpHeader[2] = (uint8)(McEthIp_TxHeader.TcpHeader->DstPort >> 8);
  McEthIp_TcpHeader[3] = (uint8)(McEthIp_TxHeader.TcpHeader->DstPort & 0x00FF);
  /* Sequence Number  4 Byte */
  McEthIp_TcpHeader[4] = (uint8)(McEthIp_TxHeader.TcpHeader->SeqNumber >> 24);
  McEthIp_TcpHeader[5] = (uint8)(McEthIp_TxHeader.TcpHeader->SeqNumber >> 16);
  McEthIp_TcpHeader[6] = (uint8)(McEthIp_TxHeader.TcpHeader->SeqNumber >> 8);
  McEthIp_TcpHeader[7] = (uint8)(McEthIp_TxHeader.TcpHeader->SeqNumber & 0x00FF);
  /* Aknowledgment Number  4 Bytes */
  McEthIp_TcpHeader[8] = (uint8)(McEthIp_TxHeader.TcpHeader->Aknowledgment >> 24);
  McEthIp_TcpHeader[9] = (uint8)(McEthIp_TxHeader.TcpHeader->Aknowledgment >> 16);
  McEthIp_TcpHeader[10] = (uint8)(McEthIp_TxHeader.TcpHeader->Aknowledgment >> 8);
  McEthIp_TcpHeader[11] = (uint8)(McEthIp_TxHeader.TcpHeader->Aknowledgment & 0x00FF);
  /* Data Offset 1 Byte */
  McEthIp_TcpHeader[12] = McEthIp_TxHeader.TcpHeader->DataOffset;
  /* Flags 1 Byte */
  McEthIp_TcpHeader[13] = McEthIp_TxHeader.TcpHeader->Flags;
  /* Window Size 2 Bytes */
  McEthIp_TcpHeader[14] = (uint8)(McEthIp_TxHeader.TcpHeader->WindowSize >> 8);
  McEthIp_TcpHeader[15] = (uint8)(McEthIp_TxHeader.TcpHeader->WindowSize & 0x00FF);
  /* CheckSum Is 0 for now 2 Bytes */
  McEthIp_TcpHeader[16] = 0;
  McEthIp_TcpHeader[17] = 0;
  /* UrgentPointer 2 Bytes */
  McEthIp_TcpHeader[18] = (uint8)(McEthIp_TxHeader.TcpHeader->UrgentPointer >> 8);
  McEthIp_TcpHeader[19] = (uint8)(McEthIp_TxHeader.TcpHeader->UrgentPointer & 0x00FF);

  McEthUpdateTcpCheckSum(McEthIp_TcpHeader, MCETHIP_HEADER_LEN);

  /* CheckSum 2 Bytes */
  McEthIp_TcpHeader[16] = (uint8)(McEthIp_TxHeader.TcpHeader->CheckSum >> 8);
  McEthIp_TcpHeader[17] = (uint8)(McEthIp_TxHeader.TcpHeader->CheckSum & 0x00FF);

  /* Push Tcp Header to buffer */
  if (McEth_PushTransmitMessage(McEthIp_TcpHeader, MCETHIP_HEADER_LEN))
  {
    /* Ok */
  }
  else
  {
    /* Buffer is full */
  }

  McEthIp_TxHeader.TcpHeader->SeqNumber++;
}



/** \brief Calculates the Payload's checksum and adds the payload to transmit buffer
 * \param McEth_SendPayload
 * \return void
 */
static void McEth_SendPayload(uint8* DataPayload, uint16 PayloadSize)
{
  uint16 PayloadRemain = PayloadSize;
  uint16 counter = 128;
  uint8 NewCheckSum[2];

  while (PayloadRemain >= 128)
  {
    Dma_SetSourceAddress (&McEthiIp_DmaPachetHandler, (uint32)&DataPayload[counter - 128]);
    Dma_SetDestinationAddress(&McEthiIp_DmaPachetHandler, (uint32)&McEthIp_TransmitBuffer[0]);
    Dma_Transfer(&McEthiIp_DmaPachetHandler);
    McEthUpdateTcpCheckSum(McEthIp_TransmitBuffer, MCETHIP_DATASIZE);
    McEth_PushTransmitMessage(McEthIp_TransmitBuffer, MCETHIP_DATASIZE);
    PayloadRemain -= 128;
    /* Multiply by 2 */
    counter<<=1;
  }

  if (PayloadRemain > 0)
  {
    IfxDma_Dma_setChannelTransferCount(&McEthiIp_DmaPachetHandler, PayloadRemain);
    Dma_SetSourceAddress (&McEthiIp_DmaPachetHandler, (uint32)&DataPayload[counter]);
    Dma_SetDestinationAddress(&McEthiIp_DmaPachetHandler, (uint32)&McEthIp_TransmitBuffer[0]);
    Dma_Transfer(&McEthiIp_DmaPachetHandler);
    McEthUpdateTcpCheckSum(McEthIp_TransmitBuffer, PayloadRemain);
    McEth_PushTransmitMessage(McEthIp_TransmitBuffer, PayloadRemain);

  }
  else
  {
    /* Do nothing after this */
  }
  /* Update the checksum in the checksum area of the transmit memory */
  /* CheckSum 2 Bytes */
  NewCheckSum[0] = (uint8)(McEthIp_TxHeader.TcpHeader->CheckSum >> 8);
  NewCheckSum[1] = (uint8)(McEthIp_TxHeader.TcpHeader->CheckSum & 0x00FF);
  McEth_WriteTransmitMemory(McEthIp_TransmitTcpChecksum, NewCheckSum, sizeof(NewCheckSum));
}



/** \brief Creates a whole TCP packet along with ethernet, ip and tcp header
 * \param McEthIp_InitTcpTransmitPacket
 * \return void
 */
void McEthIp_InitTcpTransmitPacket(uint8* DstMacAddress ,MCETHIP_IP* IpAddress, uint8* DataPayload, uint16 PayloadSize)
{
  uint8 Ipv4Type[2] = {0x08, 0x00};
  switch (McEthIp_TransmitState)
  {
    case ETH_TRANSMIT_IDLE:
      McEthIp_TransmitState = SEND_ETHERNET_HEADER;
      break;

    case SEND_ETHERNET_HEADER:
      McEth_CreateTransmitPacket(DstMacAddress, Ipv4Type);
      McEthIp_TransmitState = SEND_IP_HEADER;
      break;

    case SEND_IP_HEADER:
      McEth_CreateIpHeader(IpAddress, PayloadSize);
      McEthIp_TransmitState = SEND_TCP_HEADER;
      break;
    case SEND_TCP_HEADER:
      McEth_CreateTcpHeader(PayloadSize);
      McEthIp_TransmitState = SEND_PAYLOAD;
      break;

    case SEND_PAYLOAD:
      McEth_SendPayload(DataPayload, PayloadSize);
      /* Send the message */
      if (McEth_TransmitMessage())
      {
        McEthIp_TransmitState = ETH_TRANSMIT_VALIDATE;
      }
      else
      {

        McEthIp_TransmitState = ETH_TRANSMIT_IDLE;
      }
      break;
    default:
      break;
  }

}



/** \brief Updates the CheckSum of the Ip Header
 * \param McEthUpdateCheckSum
 * \return void
 */
static inline void McEthUpdateIpCheckSum(uint8* McEthIp_IpHeader)
{
  uint32 CheckSum = 0;
  uint16 tmp;

  for (uint8 i = 0; i < 20; i = i+2)
  {
    tmp = (uint16)((McEthIp_IpHeader[i] << 8) | McEthIp_IpHeader[i+1]);
    CheckSum += tmp;

    if (CheckSum > 0xFFFF)
    {
      CheckSum = (CheckSum & 0xFFFF) + 1;
    }
  }
  McEthIp_IpHeader[10] = (uint8)(~CheckSum >> 8);
  McEthIp_IpHeader[11] = (uint8)(~CheckSum & 0x00FF);
}

/** \brief Calculate CheckSum of the Tcp Header
 * \param McEthUpdateTcpCheckSum
 * \return void
 */

static inline void McEthUpdateTcpCheckSum(uint8* BytesArray, uint16 size)
{
  uint32 CheckSum = (uint32)McEthIp_TxHeader.TcpHeader->CheckSum;
  for  (uint16 i = 0; i < size; i++)
  {
    CheckSum += BytesArray[i];

    if (CheckSum > 0xFFFF)
    {
      CheckSum = (CheckSum & 0xFFFF) + 1;
    }
  }
  McEthIp_TxHeader.TcpHeader->CheckSum = (uint16)CheckSum;
}


