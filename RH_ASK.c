/**********************************************************************************************************************
 * \file RH_ASK.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "RH_ASK.h"
#include "pinsReadWrite.h"
#include "INTERRUPTS.h"
#include "IfxStm.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define lo8(x) ((x)&0xff)
#define hi8(x) ((x)>>8)

#define F_CPU 100000000
#define RH_DRAM_ATTR
// This is the value of the start symbol after 6-bit conversion and nybble swapping
#define RH_ASK_START_SYMBOL 0xb38

#define NUM_PRESCALERS (sizeof(prescalers) / sizeof( uint16))
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
// 4 bit to 6 bit symbol converter table
// Used to convert the high and low nybbles of the transmitted data
// into 6 bit symbols for transmission. Each 6-bit symbol has 3 1s and 3 0s
// with at most 3 consecutive identical bits
RH_DRAM_ATTR static uint8 symbols[] =
{
    0xd,  0xe,  0x13, 0x15, 0x16, 0x19, 0x1a, 0x1c,
    0x23, 0x25, 0x26, 0x29, 0x2a, 0x2c, 0x32, 0x34
};

static const uint16 prescalers[] = {1, 16, 256, 4096, 32768,0};

IfxGtm_Tom_Timer RHASK_tom;
RH_ASK RHASK;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

// True of the sense of the rxPin is to be inverted
boolean  _rxInverted;

// Buff is filled but not validated
volatile boolean   _rxBufFull;

// Buff is full and valid
volatile boolean   _rxBufValid;

// Last digital input from the Rx data pin
volatile boolean   _rxLastSample;

// This is the integrate and dump integral. If there are <5 0 samples in the PLL cycle
// the bit is declared a 0, else a 1
volatile uint8 _rxIntegrator;

// PLL ramp, varies between 0 and RH_ASK_RX_RAMP_LEN-1 (159) over
// RH_ASK_RX_SAMPLES_PER_BIT (8) samples per nominal bit time.
// When the PLL is synchronized, bit transitions happen at about the
// 0 mark.
volatile uint8 _rxPllRamp;

// Flag indicates if we have seen the start symbol of a new message and are
// in the processes of reading and decoding it
volatile uint8 _rxActive;

// Last 12 bits received, so we can look for the start symbol
volatile uint16 _rxBits;

// How many bits of message we have received. Ranges from 0 to 12
volatile uint8 _rxBitCount;

// The incoming message buffer
uint8 _rxBuf[RH_ASK_MAX_PAYLOAD_LEN];

// The incoming message expected length
volatile uint8 _rxCount;

// The incoming message buffer length received so far
volatile uint8 _rxBufLen;

// Index of the next symbol to send. Ranges from 0 to vw_tx_len
uint8 _txIndex;

// Bit number of next bit to send
uint8 _txBit;

 // Sample number for the transmitter. Runs 0 to 7 during one bit interval
uint8 _txSample;

// The transmitter buffer in _symbols_ not data actuates
uint8 _txBuf[(RH_ASK_MAX_PAYLOAD_LEN * 2) + RH_ASK_PREAMBLE_LEN];

// Number of symbols in _txBuf to be sent;
uint8 _txBufLen;
/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void validateRxBuf(void);
void handleTimerInterrupt(void);
void timerSetup(void);
void receiveTimer(void);
void transmitTimer(void);
boolean waitPacketSent();

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(handleTimerInterrupt, 0, 15);
void handleTimerInterrupt()
{
    IfxGtm_Tom_Timer_acknowledgeTimerIrq(&RHASK_tom);
    if (RHASK.RHGeneric._mode == RHModeRx)
    receiveTimer(); // Receiving
    else if (RHASK.RHGeneric._mode == RHModeTx)
        transmitTimer(); // Transmitting
}

boolean readRx()
{
    boolean value;
    value = getPinState(RHASK.rxPinPort, RHASK.rxPinIndex);
    return value ^ _rxInverted;
}

void writePtt(boolean value)
{
    if (value==0){
        setPinOutputFalse(RHASK.pttPinPort,RHASK.pttPinIndex);
    }
    else {
        setPinOutputTrue(RHASK.pttPinPort,RHASK.pttPinIndex);
    }
}


void writeTx(boolean value)
{
    if (value==0){
        setPinOutputFalse(RHASK.txPinPort,RHASK.txPinIndex);
    }
    else {
        setPinOutputTrue(RHASK.txPinPort,RHASK.txPinIndex);
    }
}

void setModeIdle(){
    if (RHASK.RHGeneric._mode != RHModeIdle){
        writePtt(0);
        writeTx(0);
        RHASK.RHGeneric._mode = RHModeIdle;
    }
}

void setModeRx()
{
    if (RHASK.RHGeneric._mode != RHModeRx)
    {
    // Disable the transmitter hardware
    writePtt(0);
    writeTx(0);
    RHASK.RHGeneric._mode = RHModeRx;
    }
}

void setModeTx()
{
    if (RHASK.RHGeneric._mode != RHModeTx)
    {
    // PRepare state varibles for a new transmission
    _txIndex = 0;
    _txBit = 0;
    _txSample = 0;

    // Enable the transmitter hardware
    writePtt(1);

    RHASK.RHGeneric._mode = RHModeTx;
    }
}

boolean RHGenericDriver_Init(){
    RHASK.RHGeneric._mode = RHModeInitialising;
    RHASK.RHGeneric._thisAddress = RH_BROADCAST_ADDRESS;
    RHASK.RHGeneric._txHeaderTo = RH_BROADCAST_ADDRESS;
    RHASK.RHGeneric._txHeaderFrom = RH_BROADCAST_ADDRESS;
    RHASK.RHGeneric._txHeaderId = 0;
    RHASK.RHGeneric._txHeaderFlags = 0;
    RHASK.RHGeneric._rxBad = 0;
    RHASK.RHGeneric._rxGood = 0;
    RHASK.RHGeneric._txGood = 0;
    RHASK.RHGeneric._cad_timeout = 0;
    return 1;
}

boolean RH_ASK_Init(float32 speed,Ifx_P* rxPort ,uint8 rxPin,Ifx_P* txPort, uint8 txPin,Ifx_P* pttPort, uint8 pttPin, boolean pttInverted){
    RHASK.speed = speed;
    RHASK.rxPinPort = rxPort;
    RHASK.rxPinIndex = rxPin;
    RHASK.txPinPort = txPort;
    RHASK.txPinIndex = txPin;
    RHASK.pttPinPort = pttPort;
    RHASK.pttPinIndex = pttPin;
    _rxInverted = 0;
    RHASK.pttInverted = pttInverted;
    uint8 preamble[RH_ASK_PREAMBLE_LEN] = {0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x38, 0x2c};
    memcpy(_txBuf, preamble, sizeof(preamble));
    if (!RHGenericDriver_Init()){
        return 0;
    }
    setPinOutput(RHASK.txPinPort,RHASK.txPinIndex);
    setPinInputPuldown(RHASK.rxPinPort,RHASK.rxPinIndex);
    setPinOutput(RHASK.pttPinPort,RHASK.pttPinIndex);
    setModeIdle();
    timerSetup();
    return 1;
}

uint8 timerCalc(float32 speed,uint16 max_ticks, float32 *nticks){

    uint8 prescaler;
    unsigned long ulticks;
    if (speed == 0)
    {
        // signal fault
        *nticks = 0;
        return 0;
    }
    uint16 prescalerValue =  0;
    uint16 inv_bit_time = ((uint16)speed) * 8;
    for (prescaler = 0; prescaler < NUM_PRESCALERS-1; prescaler += 1)
        {
        // Integer arithmetic courtesy Jim Remington
        // 1/Amount of time per CPU clock tick (in seconds)
        prescalerValue = prescalers[prescaler];
            unsigned long inv_clock_time = F_CPU / ((unsigned long)prescalerValue);
            // number of prescaled ticks needed to handle bit time @ speed
            ulticks = inv_clock_time / inv_bit_time;

            // Test if ulticks fits in nticks bitwidth (with 1-tick safety margin)
            if ((ulticks > 1) && (ulticks < max_ticks))
                break; // found prescaler

            // Won't fit, check with next prescaler value
        }

    // Check for error
    if ((prescaler == 5) || (ulticks < 2) || (ulticks > max_ticks))
    {
        // signal fault
        return 0;
    }
    return prescaler;
}

void timerSetup(){
    float32 nticks = 8*RHASK.speed; // number of prescaled ticks needed
    uint8 prescaler;

    prescaler = timerCalc(RHASK.speed,(uint16)-1,&nticks);
    if (prescaler==5){
            return;
    }

    initTomInterrupt(&RHASK_tom,nticks,15,1,4, prescaler);

}


boolean available(){
    if(RHASK.RHGeneric._mode == RHModeTx){
            return 0;
    }
    setModeRx();
    if (_rxBufFull)
    {
       validateRxBuf();
       _rxBufFull= 0;
     }
   return _rxBufValid;
}


boolean recv(uint8* buf, uint8* len)
{
    if (!available())
    return 0;

    if (buf && len)
    {
    // Skip the length and 4 headers that are at the beginning of the rxBuf
    // and drop the trailing 2 bytes of FCS
    uint8 message_len = _rxBufLen-RH_ASK_HEADER_LEN - 3;
    if (*len > message_len)
        *len = message_len;
    memcpy(buf, _rxBuf+RH_ASK_HEADER_LEN+1, *len);
    }
    _rxBufValid = 0; // Got the most recent message, delete it
//    printBuffer("recv:", buf, *len);
    return 1;
}



//function to calculate the crc and change the data in order to be
//transmitted properly and checked for corrections from the receiver
uint16 RHcrc_ccitt_update (uint16 crc, uint8 data)
{
    data ^= lo8 (crc);
    data ^= data << 4;

    return ((((uint16)data << 8) | hi8 (crc)) ^ (uint8)(data >> 4)
        ^ ((uint16)data << 3));
}

//boolean function to wait if module is on receiving mode
boolean waitPacketSent(){
    while(RHASK.RHGeneric._mode == RHModeTx);
    return 1;
}

boolean isChannelActive()
{
    return 0;
}

boolean waitCAD()
{
    if (!RHASK.RHGeneric._cad_timeout)
    return 1;

    // Wait for any channel activity to finish or timeout
    // Sophisticated DCF function...
    // DCF : BackoffTime = random() x aSlotTime
    // 100 - 1000 ms
    // 10 sec timeout
    uint64 t = IfxStm_get(&MODULE_STM0)/(IfxStm_getFrequency(&MODULE_STM0)*1000);
    while (isChannelActive())
    {
      if (IfxStm_get(&MODULE_STM0)/(IfxStm_getFrequency(&MODULE_STM0)*1000) - t > RHASK.RHGeneric._cad_timeout){
         return 0;
         }
     Ifx_TickTime randTime =IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,((rand()&10)+1) * 100);
     wait(randTime);

    }

    return 1;
}

//calculates the crc of bits to be transmited on txbuffer and then sends them
boolean send(const uint8* data, uint8 len)
{
    uint8 i;
    uint16 index = 0;
    uint16 crc = 0xffff;
    uint8 *p = _txBuf + RH_ASK_PREAMBLE_LEN; // start of the message area
    uint8 count = len + 3 + RH_ASK_HEADER_LEN; // Added byte count and FCS and headers to get total number of bytes

    if (len > RH_ASK_MAX_MESSAGE_LEN)
    return 0;

    // Wait for transmitter to become available
    waitPacketSent();

    if (!waitCAD())
    return 0;  // Check channel activity

    // Encode the message length
    crc = RHcrc_ccitt_update(crc, count);
    p[index++] = symbols[count >> 4];
    p[index++] = symbols[count & 0xf];

    // Encode the headers
    crc = RHcrc_ccitt_update(crc, RHASK.RHGeneric._txHeaderTo);
    p[index++] = symbols[RHASK.RHGeneric._txHeaderTo >> 4];
    p[index++] = symbols[RHASK.RHGeneric._txHeaderTo & 0xf];
    crc = RHcrc_ccitt_update(crc, RHASK.RHGeneric._txHeaderFrom);
    p[index++] = symbols[RHASK.RHGeneric._txHeaderFrom >> 4];
    p[index++] = symbols[RHASK.RHGeneric._txHeaderFrom & 0xf];
    crc = RHcrc_ccitt_update(crc, RHASK.RHGeneric._txHeaderId);
    p[index++] = symbols[RHASK.RHGeneric._txHeaderId >> 4];
    p[index++] = symbols[RHASK.RHGeneric._txHeaderId & 0xf];
    crc = RHcrc_ccitt_update(crc, RHASK.RHGeneric._txHeaderFlags);
    p[index++] = symbols[RHASK.RHGeneric._txHeaderFlags >> 4];
    p[index++] = symbols[RHASK.RHGeneric._txHeaderFlags & 0xf];

    // Encode the message into 6 bit symbols. Each byte is converted into
    // 2 6-bit symbols, high nybble first, low nybble second
    for (i = 0; i < len; i++)
    {
    crc = RHcrc_ccitt_update(crc, data[i]);
    p[index++] = symbols[data[i] >> 4];
    p[index++] = symbols[data[i] & 0xf];
    }

    // Append the fcs, 16 bits before encoding (4 6-bit symbols after encoding)
    // Caution: VW expects the _ones_complement_ of the CCITT CRC-16 as the FCS
    // VW sends FCS as low byte then hi byte
    crc = ~crc;
    p[index++] = symbols[(crc >> 4)  & 0xf];
    p[index++] = symbols[crc & 0xf];
    p[index++] = symbols[(crc >> 12) & 0xf];
    p[index++] = symbols[(crc >> 8)  & 0xf];

    // Total number of 6-bit symbols to send
    _txBufLen = index + RH_ASK_PREAMBLE_LEN;

    // Start the low level interrupt handler sending symbols
    setModeTx();

    return 1;
}


uint8 symbol_6to4(uint8 symbol)
{
    uint8 i;
    uint8 count;

    // Linear search :-( Could have a 64 byte reverse lookup table?
    // There is a little speedup here courtesy Ralph Doncaster:
    // The shortcut works because bit 5 of the symbol is 1 for the last 8
    // symbols, and it is 0 for the first 8.
    // So we only have to search half the table
    for (i = (symbol>>2) & 8, count=8; count-- ; i++)
    if (symbol == symbols[i]) return i;

    return 0; // Not found
}


//validate the Rxbuffer fi bits are ok
void validateRxBuf()
{
    uint16 crc = 0xffff;
    // The CRC covers the byte count, headers and user data
    for (uint8 i = 0; i < _rxBufLen; i++)
    crc = RHcrc_ccitt_update(crc, _rxBuf[i]);
    if (crc != 0xf0b8) // CRC when buffer and expected CRC are CRC'd
    {
    // Reject and drop the message
    RHASK.RHGeneric._rxBad++;
    _rxBufValid = 0;
    return;
    }

    // Extract the 4 headers that follow the message length
    RHASK.RHGeneric._rxHeaderTo    = _rxBuf[1];
    RHASK.RHGeneric._rxHeaderFrom  = _rxBuf[2];
    RHASK.RHGeneric._rxHeaderId    = _rxBuf[3];
    RHASK.RHGeneric._rxHeaderFlags = _rxBuf[4];
    if (RHASK.RHGeneric._promiscuous ||
            RHASK.RHGeneric._rxHeaderTo == RHASK.RHGeneric._thisAddress ||
            RHASK.RHGeneric._rxHeaderTo == RH_BROADCAST_ADDRESS)
    {
        RHASK.RHGeneric._rxGood++;
        _rxBufValid = 1;
    }
}

//receive timer interrupt
void receiveTimer()
{
    boolean rxSample = readRx();

    // Integrate each sample
    if (rxSample)
    _rxIntegrator++;

    if (rxSample != _rxLastSample)
    {
    // Transition, advance if ramp > 80, retard if < 80
    _rxPllRamp += ((_rxPllRamp < RH_ASK_RAMP_TRANSITION)
               ? RH_ASK_RAMP_INC_RETARD
               : RH_ASK_RAMP_INC_ADVANCE);
    _rxLastSample = rxSample;
    }
    else
    {
    // No transition
    // Advance ramp by standard 20 (== 160/8 samples)
    _rxPllRamp += RH_ASK_RAMP_INC;
    }
    if (_rxPllRamp >= RH_ASK_RX_RAMP_LEN)
    {
    // Add this to the 12th bit of _rxBits, LSB first
    // The last 12 bits are kept
    _rxBits >>= 1;

    // Check the integrator to see how many samples in this cycle were high.
    // If < 5 out of 8, then its declared a 0 bit, else a 1;
    if (_rxIntegrator >= 5)
        _rxBits |= 0x800;

    _rxPllRamp -= RH_ASK_RX_RAMP_LEN;
    _rxIntegrator = 0; // Clear the integral for the next cycle

    if (_rxActive)
    {
        // We have the start symbol and now we are collecting message bits,
        // 6 per symbol, each which has to be decoded to 4 bits
        if (++_rxBitCount >= 12)
        {
        // Have 12 bits of encoded message == 1 byte encoded
        // Decode as 2 lots of 6 bits into 2 lots of 4 bits
        // The 6 lsbits are the high nybble
        uint8 this_byte =
            (symbol_6to4(_rxBits & 0x3f)) << 4
            | symbol_6to4(_rxBits >> 6);

        // The first decoded byte is the byte count of the following message
        // the count includes the byte count and the 2 trailing FCS bytes
        // REVISIT: may also include the ACK flag at 0x40
        if (_rxBufLen == 0)
        {
            // The first byte is the byte count
            // Check it for sensibility. It cant be less than 7, since it
            // includes the byte count itself, the 4 byte header and the 2 byte FCS
            _rxCount = this_byte;
            if (_rxCount < 7 || _rxCount > RH_ASK_MAX_PAYLOAD_LEN)
            {
            // Stupid message length, drop the whole thing
            _rxActive = 0;
            RHASK.RHGeneric._rxBad++;
                        return;
            }
        }
        _rxBuf[_rxBufLen++] = this_byte;

        if (_rxBufLen >= _rxCount)
        {
            // Got all the bytes now
            _rxActive = 0;
            _rxBufFull = 0;
            setModeIdle();
        }
        _rxBitCount = 0;
        }
    }
    // Not in a message, see if we have a start symbol
    else if (_rxBits == RH_ASK_START_SYMBOL)
    {
        // Have start symbol, start collecting message
        _rxActive = 1;
        _rxBitCount = 0;
        _rxBufLen = 0;
    }
    }
}

void transmitTimer()
{
    if (_txSample++ == 0)
    {
    // Send next bit
    // Symbols are sent LSB first
    // Finished sending the whole message? (after waiting one bit period
    // since the last bit)
    if (_txIndex >= _txBufLen)
    {
        setModeIdle();
        RHASK.RHGeneric._txGood++;
    }
    else
    {
        writeTx(_txBuf[_txIndex] & (1 << _txBit++));
        if (_txBit >= 6)
        {
        _txBit = 0;
        _txIndex++;
        }
    }
    }

    if (_txSample > 7)
    _txSample = 0;
}




