/**********************************************************************************************************************
 * \file McEthernetHandler.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "McEthernetHandler.h"
#include "McEthernetPacket.h"
#include "McEthernetIp.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define DMA_ETH_HANDLER_STORE_PRIORITY 8
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
static volatile boolean McEthHandler_StoreSuccess = FALSE;
IfxDma_Dma_Channel McEthHandler_DmaStorePayload;
static uint16 McEthHandler_StoreIndex = 0;
MCETHHANDLER_ARP McEthHandler_ARPstate = SEND_ARP_REQUEST;
MCETHHANDLER_TCP McEthHandler_TcpState = SEND_TCP_PACKET;
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/** \brief Dma Isr to store 200 bytes in the Handler
 * \param McEthHandler_DmaStoreIsr
 * \return void
 */
IFX_INTERRUPT(McEthHandler_DmaStoreIsr, 0, DMA_ETH_HANDLER_STORE_PRIORITY);
void McEthHandler_DmaStoreIsr(void)
{
  McEthHandler_StoreSuccess = TRUE;
}



/** \brief Init of the Ethernet Module
 * \param McEthHandler_DmaStoreIsr
 * \return void
 */
void McEthHandler_Init(uint8* SrcMacAddress)
{
  /* Initialize the Source and Destination to be the same  then it will change in the next transaction */
  Dma_Init(&McEthHandler_DmaStorePayload, MC_ETHERNET_DATASIZE, (uint32)(&McEth_Payload.Buffer[0]), (uint32)(&McEth_Payload.Buffer[0]), DMA_ETH_HANDLER_STORE_PRIORITY,IfxDma_ChannelIncrementCircular_none, IfxDma_ChannelIncrementCircular_2048);
  /* Init the Ethernet Module */
  McEth_Init(SrcMacAddress);
}



/** \brief Stores Bytes to the buffer
 * \param McEthHandler_DmaStoreIsr
 * \return void
 */
void McEthHandler_StoreBytes(uint8* Data, uint16 Size)
{
  IfxDma_Dma_setChannelTransferCount(&McEthHandler_DmaStorePayload, Size);
  /* We choose the next index since we don't read at the same time we write with SPI during the first byte */
  Dma_SetSourceAddress (&McEthHandler_DmaStorePayload, (uint32)&Data[0]);
  Dma_SetDestinationAddress(&McEthHandler_DmaStorePayload, (uint32)&McEth_Payload.Buffer[McEthHandler_StoreIndex]);
  Dma_Transfer(&McEthHandler_DmaStorePayload);
  McEthHandler_StoreIndex = (McEthHandler_StoreIndex + Size) % MC_ETHERNET_DMASIZE;
  /* Wait till the Transmition is completed */
  while (McEthHandler_StoreSuccess==FALSE) {}

  McEthHandler_StoreSuccess=FALSE;
  McEth_Payload.WriteBufferSize += Size;
}



/** \brief Stores the actual Write Index in the Store Index
 * \param McEthHandler_StoreWriteIndex
 * \return void
 */
void McEthHandler_StoreWriteIndex(void)
{
  McEthHandler_StoreIndex = McEth_Payload.WriteIndex;
}



/** \brief Main Handler Function where the ARP request happens
 * \param McEthHandler_ARPRequest
 * \return void
 */
void McEthHandler_ARPRequest(uint8* DstIpAddress)
{
  McEthIp_SendARPState = ETH_CREATE_ARP;
  switch (McEthHandler_ARPstate)
  {
    case SEND_ARP_REQUEST:
    {
      McEthIp_SendARP(DstIpAddress);
      if (McEthIp_SendARPState == ETH_SUCCESS_SEND_ARP)
      {
        /* Return Back to init state */
        McEthIp_SendARPState = ETH_CREATE_ARP;
        McEthHandler_ARPstate = VALIDATE_ARP_REQUEST;
      }
      else if (McEthIp_SendARPState == ETH_FAIL_SEND_ARP)
      {
        McEthIp_SendARPState = ETH_CREATE_ARP;
        McEthHandler_ARPstate = AR_REQUEST_FAIL;
      }
    }
    break;

    case VALIDATE_ARP_REQUEST:
    {
      McEthIp_GetARP();
      if (McEthIp_GetARPState == ETH_SUCCESS_RECEIVE_ARP)
      {
        McEthIp_GetARPState = ETH_GET_ARP;
        McEthHandler_ARPstate = ARP_REQUEST_SUCCESS;
      }
      else if (McEthIp_GetARPState == ETH_FAIL_RECEIVE_ARP)
      {
        /* Resend the Message */
        McEthIp_GetARPState = ETH_GET_ARP;
        McEthHandler_ARPstate = SEND_ARP_REQUEST;
      }
      else
      {

      }
    }
    break;

    default:
      break;
  }
}



/** \brief Main Handler Function Packet Transmittion and Reception happens
 * \param McEthHandler_TcpPacketMain
 * \return void
 */
void McEthHandler_TcpPacketMain(void)
{
  switch (McEthHandler_TcpState)
  {
    case SEND_TCP_PACKET:
    {
      McEthIp_TcpTransmitPacket();
      if (McEthIp_TransmitState == ETH_SEND_SUCCESS)
      {
        McEthIp_TransmitState = ETH_TRANSMIT_IDLE;
        McEthHandler_TcpState = RECEIVE_TCP_PACKET;
      }
      else if (McEthIp_TransmitState == ETH_SEND_FAIL)
      {
        McEthIp_TransmitState = ETH_TRANSMIT_IDLE;
        McEthHandler_TcpState = TCP_HANDLE_FAIL;
      }
      else
      {

      }
    }
    break;

    case RECEIVE_TCP_PACKET:
    {
      McEthIp_TcpReceivePacket();
      if (McEthIp_ReceiveState == ETH_READ_SUCCESS)
      {
        McEthIp_ReceiveState = ETH_RECEIVE_IDLE;
        McEthHandler_TcpState = TCP_HANDLE_SUCCESS;
      }
      else if (McEthIp_ReceiveState == ETH_READ_FAIL)
      {
        McEthIp_ReceiveState = ETH_RECEIVE_IDLE;
        /* Packet Lost or didn't received send the tcp again */
        McEthHandler_TcpState = SEND_TCP_PACKET;
      }
      else
      {

      }
      break;
    }

    default:
      break;
  }
}
