/**********************************************************************************************************************
 * \file McEthernet.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "McEthernet.h"
#include "pinsReadWrite.h"
#include "Bsp.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define MC_ETHERNET_MAXFRAME     1500
#define MC_ETHERNET_RESET        &MODULE_P33,10
#define MC_ETHERNET_SPIBAUDRATE  10000000
#define MC_ETHERNET_WRITECOMMAND 2
#define MC_ETHERNET_READCOMMAND  0
#define MC_ETHERNET_WRITEBUFFER  0x7A
#define MC_ETHERNET_READBUFFER   0x3A
#define MC_ETHERNET_SETBIT       0x4
#define MC_ETHERNET_CLEARBIT     0x5
#define MC_ETHERNET_MACSIZE      6
#define MC_ETHERNET_TYPESIZE     2
#define MC_ETHERNET_MAXFRAMESIZE 200
#define MC_ETHERNET_DATASIZE     128
#define BANK0                    0
#define BANK1                    1
#define BANK2                    2
#define BANK3                    3
#define ECOCON                   0x15
#define ECON1                    0x1F
#define ECON2                    0x1E
#define MACON1                   0x00
#define MACON3                   0x02
#define MACON4                   0x03
#define ERXFCON                  0x18
#define MAADR1                   0x04
#define MAADR2                   0x05
#define MAADR3                   0x02
#define MAADR4                   0x03
#define MAADR5                   0x00
#define MAADR6                   0x01
#define MAMXFLL                  0x0A
#define MAMXFLH                  0x0B
#define ETXSTL                   0x04
#define ETXSTH                   0x05
#define ETXNDL                   0x06
#define ETXNDH                   0x07
#define ERDPTL                   0x00
#define ERDPTH                   0x01
#define EWRPTL                   0x02
#define EWRPTH                   0x03
#define ERXSTL                   0x08
#define ERXSTH                   0x09
#define ESTAT                    0x1D
#define ERXNDL                   0x0A
#define ERXNDH                   0x0B
#define EIR                      0x1C
#define EIE                      0x1B
#define MABBIPG                  0x04
#define MAIPGL                   0x06
#define MAIPGH                   0x07
#define EPKTCNT                  0x19
#define ERXWRPTL                 0x0E
#define ERXWRPTH                 0x0F
#define EPMM0                    0x08
#define EPMCSL                   0x10
#define EPMCSH                   0x11
#define ERXRDPTL                 0x0C
#define ERXRDPTH                 0x0D
#define EPMOL                    0x14
#define EPMOH                    0x15
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* SPI Configuration Registers */
SpiMasterPins_t McEthernetPins = {
    &IfxQspi1_SCLK_P10_2_OUT,
    &IfxQspi1_MTSR_P10_3_OUT,
    &IfxQspi1_MRSTA_P10_1_IN
};

SpiMaster_t McEthernetSpiMaster;

SpiMasterCfg_t McEthernetSpiConfig = {
    &McEthernetSpiMaster,
    46,
    47,
    48
};

SpiChannel_t McEthernetChannel;

SpiChannelConfig McEthernetChannelCfg = {
    &IfxQspi1_SLSO5_P11_2_OUT,
    MC_ETHERNET_SPIBAUDRATE,
    0,
    SpiIf_ShiftClock_shiftTransmitDataOnTrailingEdge,
    SpiIf_DataHeading_msbFirst
};

/* Definition of the Ethernet packet specific parts */
static uint8 McEthernet_TxDstMacAddress[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
static uint8 McEthernet_TxSrcMacAddress[6] = {0, 0, 0, 0, 0, 0};
static uint8 McEthernet_RxDstMacAddress[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
static uint8 McEthernet_RxSrcMacAddress[6] = {0, 0, 0, 0, 0, 0};
static uint8 McEthernet_TxTypeLength[2] = {0x00, 0x00};
static uint8 McEthernet_RxTypeLength[2] = {0x00, 0x00};
static uint8 McEthernet_TxMsg[128];
static uint8 McEthernet_RxMsg[128];
static uint8 McEthernet_TransmitStatusVector[7];
static uint8 McEthernet_ReceiveStatusVector[4] = {0, 0, 0, 0};
static uint16 McEthernet_WriteAddress = 0;
static uint16 McEthernet_ReadAddress = 0;
static uint8 McEthernet_ReceivePacketNum = 0;

static McEthernet_Packet McEthernet_MasterPacketTransmit =
{
    McEthernet_TxDstMacAddress,
    McEthernet_TxSrcMacAddress,
    McEthernet_TxTypeLength,
    McEthernet_TxMsg,
    MC_ETHERNET_MACSIZE,
    MC_ETHERNET_TYPESIZE,
    MC_ETHERNET_DATASIZE,
    TRANSMIT_MESSAGE
};

static McEthernet_Packet McEthernet_MasterPacketReceive =
{
    McEthernet_RxSrcMacAddress,
    McEthernet_RxDstMacAddress,
    McEthernet_RxTypeLength,
    McEthernet_RxMsg,
    MC_ETHERNET_MACSIZE,
    MC_ETHERNET_TYPESIZE,
    MC_ETHERNET_DATASIZE,
    RECEIVE_MESSAGE
};

static uint8 McEthernet_RxBuffer[2];
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void McEthernet_WriteRegister(uint8 Register, uint8 Command);
static uint8 McEthernet_ReadRegister(uint8 Register);
static void McEthernet_WriteBuffer(uint8* Command, uint16 CommandSize);
static void McEthernet_ReadBuffer(uint8* Result ,uint16 ResultSize);
static void McEthernet_SetBit(uint8 Register, uint8 Mask);
static void McEthernet_ClearBit(uint8 Register, uint8 Mask);
static void McEthernet_ReadTransmitStatusVector(void);
static void McEthernet_SetBank(uint8 Bank);
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(SpimasterTxMcEthernet, 0, 46);                  /* SPI Master ISR for transmit data         */
IFX_INTERRUPT(SpimasterRxMcEthernet, 0, 47);                  /* SPI Master ISR for receive data          */
IFX_INTERRUPT(SpimasterErMcEthernet, 0, 48);                 /* SPI Master ISR for error                 */


 void SpimasterTxMcEthernet(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrTransmit(McEthernetSpiConfig.SpiMasterPtr);
 }

 void SpimasterRxMcEthernet(void )
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrReceive(McEthernetSpiConfig.SpiMasterPtr);
 }

 void SpimasterErMcEthernet(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrError(McEthernetSpiConfig.SpiMasterPtr);
 }



/** \brief Update internal data when incremental mode is using T2.\n
 * This function is the SPI, RESET_PIN and Microchip ethernet module configuration
 * \param McEthernet_Init configuration setup function
 * \return None
 */
void McEthernet_Init(uint8* MacAddress)
{
  uint8 tmp;
  Ifx_TickTime delay100ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,100);
  Ifx_TickTime delay1ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,1);
  /* Reset the module */
  setPinOutput(MC_ETHERNET_RESET);
  wait(delay1ms);
  setPinOutputTrue(MC_ETHERNET_RESET);

  Spi_Init(&McEthernetPins, &McEthernetSpiConfig);
  Spi_ChannelInit(&McEthernetSpiConfig, &McEthernetChannel,&McEthernetChannelCfg);
  wait(delay100ms);

  /* Bank 0 register */
  McEthernet_SetBank(BANK0);

  /* Receive Buffer space */
  McEthernet_WriteRegister(ERXNDL, (uint8)(0xFFF & 0x00FF));
  McEthernet_WriteRegister(ERXNDH, (uint8)(0xFFF >> 8));

  McEthernet_WriteRegister(ERXSTL, (uint8)(0x000 & 0x00FF));
  McEthernet_WriteRegister(ERXSTH, (uint8)(0x000 >> 8));

  McEthernet_WriteRegister(ERXRDPTL, (uint8)(0xFFE & 0x00FF));
  McEthernet_WriteRegister(ERXRDPTH, (uint8)(0xFFE >> 8));

  /* Initialize read pointer */
  McEthernet_WriteRegister(ERDPTL, (uint8)(0x002 & 0x00FF));
  McEthernet_WriteRegister(ERDPTH, (uint8)(0x002 >> 8));

  McEthernet_ReadAddress = 0x000;

  /* Transmit Buffer space */
  McEthernet_WriteRegister(ETXNDL, (uint8)(0x1000 & 0x00FF));
  McEthernet_WriteRegister(ETXNDH, (uint8)(0x1000 >> 8));

  McEthernet_WriteRegister(ETXSTL, (uint8)(0x1000 & 0x00FF));
  McEthernet_WriteRegister(ETXSTH, (uint8)(0x1000 >> 8));

  McEthernet_WriteAddress = 0x1000;

  /* Bank 1 register */
  McEthernet_SetBank(BANK1);

  /* Filter receive register */
  McEthernet_WriteRegister(ERXFCON, 0xE0);

  /* PATTERN REGISTERS are set 0x0800  (this need to be checked one day still doesn't work) */
  McEthernet_WriteRegister(EPMOL, 0x00);
  McEthernet_WriteRegister(EPMOH, 0x00);
  McEthernet_WriteRegister(EPMCSL, 0x00);
  McEthernet_WriteRegister(EPMCSH, 0x08);
  McEthernet_WriteRegister(EPMM0, 0x00);
  McEthernet_WriteRegister((EPMM0 + 1), 0x30);
  for (uint8 i = 2; i < 8; i++)
  {
    McEthernet_WriteRegister((EPMM0 + i), 0x00);
  }

  /* Wait for OST */
  while ((McEthernet_ReadRegister(ESTAT) & 0x1) != 0x1) {}

  McEthernet_ReceivePacketNum = McEthernet_ReadRegister(EPKTCNT);


  /* Bank 2 register */
  McEthernet_SetBank(BANK2);
  tmp = McEthernet_ReadRegister(ECON1);
 /* MACON 1 */
  McEthernet_WriteRegister(MACON1, 0xF);

  /* MACON 3 */
  McEthernet_WriteRegister(MACON3, 0xF6);

  /* MACON 4 */
  McEthernet_WriteRegister(MACON4, 0x40);

  /* Max Number of bytes per message */
  McEthernet_WriteRegister(MAMXFLL, (uint8)(MC_ETHERNET_MAXFRAME & 0x00FF));

  McEthernet_WriteRegister(MAMXFLH, (uint8)(MC_ETHERNET_MAXFRAME >> 8));

  /* Enable Back to Back inter packet */
  McEthernet_WriteRegister(MABBIPG, 0x12);

  /* Non back to back inter packet gap low byte */
  McEthernet_WriteRegister(MAIPGL, 0x12);
  McEthernet_WriteRegister(MAIPGH, 0xC0);

  McEthernet_SetMacAddress(MacAddress);

  /* Auto increment of buffer pointer */
  McEthernet_WriteRegister(ECON2, 0x80);
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function set ups the mac address
 * \param McEthernet_SetMacAddress configuration setup function
 * \return None
 */
void McEthernet_SetMacAddress(uint8* MacAddress)
{
  uint8 tmp;
  for (uint8 i = 0; i < MC_ETHERNET_MACSIZE; i++)
  {
    McEthernet_MasterPacketTransmit.SrcMacAddress[i] = MacAddress[i];
  }
  /* Bank 3 register */
  McEthernet_SetBank(BANK3);
  tmp = McEthernet_ReadRegister(ECON1);
  /* Mac Address registers */
  McEthernet_WriteRegister(MAADR1, MacAddress[0]);
  McEthernet_WriteRegister(MAADR2, MacAddress[1]);
  McEthernet_WriteRegister(MAADR3, MacAddress[2]);
  McEthernet_WriteRegister(MAADR4, MacAddress[3]);
  McEthernet_WriteRegister(MAADR5, MacAddress[4]);
  McEthernet_WriteRegister(MAADR6, MacAddress[5]);
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function returns true when transmition is succeed
 * \param McEthernet_SetMacAddress configuration setup function
 * \return boolean
 */
static boolean McEthernet_TransmitMsg(uint8* DstMacAddress, uint8* Type, uint8* Message, uint8 MessageSize)
{
  boolean Result = TRUE;
  uint16 MessagePacketActSize = MC_ETHERNET_MACSIZE + MC_ETHERNET_MACSIZE + MC_ETHERNET_TYPESIZE + MessageSize;
  uint16 EndAddress;

  /* Bank 0  Register */
  McEthernet_SetBank(BANK0);
  McEthernet_WriteRegister(ECON1, 0x0);

  /* Set Write Pointer */
  McEthernet_WriteRegister(EWRPTL, (uint8)((0x1000+1) & 0x00FF));
  McEthernet_WriteRegister(EWRPTH, (uint8)((0x1000+1) >> 8));

  /* End of message Address transmission */
  EndAddress = MessagePacketActSize + McEthernet_WriteAddress;

  McEthernet_WriteRegister(ETXNDL, (uint8)(EndAddress & 0x00FF));
  McEthernet_WriteRegister(ETXNDH, (uint8)(EndAddress >> 8));

  /* Wrong Message Size */
  if (MessagePacketActSize > 1520)
  {
    Result = FALSE;
  }

  static uint8 MessagePacket[128];
  for (uint8 i = 0; i < MC_ETHERNET_MACSIZE; i++)
  {
    MessagePacket[i] = McEthernet_MasterPacketTransmit.DstMacAddress[i];
  }
  McEthernet_WriteBuffer(MessagePacket, MC_ETHERNET_MACSIZE);

  for (uint8 i = 0; i < MC_ETHERNET_MACSIZE; i++)
  {
    McEthernet_MasterPacketTransmit.DstMacAddress[i] = DstMacAddress[i];
    MessagePacket[i] = McEthernet_MasterPacketTransmit.SrcMacAddress[i];
  }
  McEthernet_WriteBuffer(MessagePacket, MC_ETHERNET_MACSIZE);

  McEthernet_MasterPacketTransmit.TypeLength[0] = Type[0];
  McEthernet_MasterPacketTransmit.TypeLength[1] = Type[1];
  MessagePacket[0] = McEthernet_MasterPacketTransmit.TypeLength[0];
  MessagePacket[1] = McEthernet_MasterPacketTransmit.TypeLength[1];
  McEthernet_WriteBuffer(MessagePacket, MC_ETHERNET_TYPESIZE);

  if (MessageSize < McEthernet_MasterPacketTransmit.MessageSize)
  {
    for (uint8 i = 0; i < MessageSize; i++)
    {
      McEthernet_MasterPacketTransmit.Message[i] = Message[i];
      MessagePacket[i] = McEthernet_MasterPacketTransmit.Message[i];
    }
  }
  /* Full message transmission */
  McEthernet_WriteBuffer(MessagePacket, MessageSize);


  /* Enable transmit receive */
  McEthernet_WriteRegister(ECON1, 0x8);
  /* Clear TXIF */
  McEthernet_ClearBit(EIR, 0x8);

  /* Set TXIE, INTIE */
  McEthernet_WriteRegister(EIE, 0x88);
  uint8 EIRVAL = McEthernet_ReadRegister(EIR);

  /* RETURN AFTER transmission succeed */
  while ((EIRVAL & 0x8) == 0x8)
  {
    if ((EIRVAL & 0x2) & 0x2)
    {
      Result = FALSE;
      break;
    }
    EIRVAL = McEthernet_ReadRegister(EIR);

  }
  /* Update WriteAddress to read the Transmit Status Vector */
  McEthernet_WriteAddress = EndAddress + 1;

  McEthernet_ReadTransmitStatusVector();
  return Result;
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function handles the Transmit message success config
 * \param McEthernet_WriteMsg handle function
 * \return None
 */
void McEthernet_WriteMsg(uint8* DstMacAddress, uint8* Type, uint8* Message, uint8 MessageSize)
{
  if (McEthernet_TransmitMsg(DstMacAddress, Type, Message, MessageSize))
  {
     /* Report Something Correct */
  }
  else
  {
     /* Report Error */
  }

}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function reads the status vector during transmittion
 * \param McEthernet_ReadTransmitStatusVector read function
 * \return None
 */
static void McEthernet_ReadTransmitStatusVector(void)
{
  /* BANK 0 register */
  McEthernet_SetBank(BANK0);
  /* Set Read Pointer */
  McEthernet_WriteRegister(ERDPTL, (uint8)((McEthernet_WriteAddress) & 0x00FF));
  McEthernet_WriteRegister(ERDPTH, (uint8)((McEthernet_WriteAddress) >> 8));

  McEthernet_ReadBuffer(McEthernet_TransmitStatusVector, sizeof(McEthernet_TransmitStatusVector));

  /* Reset the Write Pointer */
  McEthernet_WriteRegister(EWRPTL, (uint8)((0x1000+1) & 0x00FF));
  McEthernet_WriteRegister(EWRPTH, (uint8)((0x1000+1) >> 8));

  McEthernet_WriteAddress = 0x1000;

}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function reads if the message is received for time in ms
 * \param McEthernert_ReceiveMsg read function
 * \return boolean
 */
static boolean McEthernert_ReceiveMsg(float32 time)
{
  uint64 stmTickTimeInit = IfxStm_get(&MODULE_STM0);
  uint64 stmTickTimeAcl;
  boolean success = FALSE;
  boolean readFlag = FALSE;
  uint16 ReceiveWritePointer;

  /* Check FIFO */
  McEthernet_SetBank(BANK0);
  ReceiveWritePointer = (uint16)((McEthernet_ReadRegister(ERXWRPTH) << 8) | (McEthernet_ReadRegister(ERXWRPTL) & 0x00FF));

  if (ReceiveWritePointer > (0x106E - 0x40))
  {
    McEthernet_WriteRegister(ERXWRPTH, (uint8)(0x838 >> 8));
    McEthernet_WriteRegister(ERXWRPTL, (uint8)(0x838 & 0x00FF));
  }

  /* Enable Rx Interrupt */
  McEthernet_WriteRegister(EIE, 0xC0);

  /* Enable Reception */
  McEthernet_WriteRegister(ECON1, 0x4);

  while (readFlag == FALSE)
  {
    /* Check if Error occured */
    if ((McEthernet_ReadRegister(EIR) & 0x1) == 0x1)
    {
      McEthernet_ClearBit(EIR, 0x1);
      McEthernet_WriteRegister(EIE, 0x81);
      McEthernet_ClearBit(ECON1, 0x4);
      success = FALSE;
      readFlag = TRUE;
    }
    stmTickTimeAcl = IfxStm_get(&MODULE_STM0);
    /* Check if Timeout occured */
    if ((stmTickTimeAcl - stmTickTimeInit) > IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, time))
    {
      McEthernet_ClearBit(ECON1, 0x4);
      success = FALSE;
      readFlag = TRUE;
    }
    /* Packet sent interrupt bit is set */
    if ((McEthernet_ReadRegister(EIR) & 0x40) == 0x40)
    {
      success = TRUE;
      McEthernet_ClearBit(ECON1, 0x4);
      readFlag = TRUE;
    }

  }
  return success;
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function reads if the message is received for ever
 * \param McEthernet_ReceiveMsgInf read function
 * \return boolean
 */
static boolean McEthernet_ReceiveMsgInf(void)
{
  boolean success = FALSE;
  boolean readFlag = FALSE;
  uint16 ReceiveWritePointer = 0;
  uint8 EIRreg = 0;

  McEthernet_SetBank(BANK0);
  /* Check FIFO */
  ReceiveWritePointer = (uint16)((McEthernet_ReadRegister(ERXWRPTH) << 8) | (McEthernet_ReadRegister(ERXWRPTL) & 0x00FF));

  if (ReceiveWritePointer > (0xFFF - 100))
  {
    McEthernet_WriteRegister(ECON1, 0x0);

    McEthernet_WriteRegister(ERXWRPTH, (uint8)(0x0 >> 8));
    McEthernet_WriteRegister(ERXWRPTL, (uint8)(0x0 & 0x00FF));

    /* Initialize read pointer */
    McEthernet_WriteRegister(ERDPTL, (uint8)(0x2 & 0x00FF));
    McEthernet_WriteRegister(ERDPTH, (uint8)(0x2 >> 8));

    McEthernet_WriteRegister(ERXRDPTL, (uint8)(0xFFE & 0x00FF));
    McEthernet_WriteRegister(ERXRDPTH, (uint8)(0xFFE >> 8));

    McEthernet_ReadAddress = 0x0;
  }

  /* Enable Rx Interrupt */
  McEthernet_WriteRegister(EIE, 0xC1);
  EIRreg = McEthernet_ReadRegister(EIE);
  /* Enable Reception */
  McEthernet_WriteRegister(ECON1, 0x4);
  McEthernet_SetBank(BANK0);


  while (readFlag == FALSE)
  {

    EIRreg = McEthernet_ReadRegister(EIR);
    /* Check if Error occured */
    if ((EIRreg & 0x1) == 0x1)
    {
      McEthernet_ClearBit(EIR, 0x1);
      McEthernet_SetBit(EIE, 0x81);
      McEthernet_ClearBit(ECON1, 0x4);
      success = FALSE;
      readFlag = TRUE;
    }
    /* Packet sent interrupt bit is set */
    if ((EIRreg & 0x40) == 0x40)
    {
      success = TRUE;
      McEthernet_ClearBit(ECON1, 0x4);
      EIRreg = McEthernet_ReadRegister(ECON1);
      readFlag = TRUE;
    }

  }
  return success;
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function reads the packet after successfull receive
 * \param McEthernet_ReadPacket read function
 * \return None
 */
static void McEthernet_ReadPacket(void)
{
  uint16 PacketBytes = 0;

  /* Bank Register 0 */
  McEthernet_SetBank(BANK0);

  /* Read Status Vector */
  McEthernet_ReadBuffer(McEthernet_ReceiveStatusVector , sizeof(McEthernet_ReceiveStatusVector));

  PacketBytes = (uint16)((McEthernet_ReceiveStatusVector[1] << 8) | (McEthernet_ReceiveStatusVector[0] & 0x00FF));

  /* Read Destination Address */
  McEthernet_ReadBuffer(McEthernet_MasterPacketReceive.DstMacAddress, McEthernet_MasterPacketReceive.MacAddressSize);
  PacketBytes -= McEthernet_MasterPacketReceive.MacAddressSize;

  /* Read Source Address */
  McEthernet_ReadBuffer(McEthernet_MasterPacketReceive.SrcMacAddress, McEthernet_MasterPacketReceive.MacAddressSize);
  PacketBytes -= McEthernet_MasterPacketReceive.MacAddressSize;

  /* Read The TypeSize */
  McEthernet_ReadBuffer(McEthernet_MasterPacketReceive.TypeLength, McEthernet_MasterPacketReceive.TypeLengthSize);
  PacketBytes -= McEthernet_MasterPacketReceive.TypeLengthSize;

  /* Read the Actual Packet */
  McEthernet_ReadBuffer(McEthernet_MasterPacketReceive.Message, PacketBytes);

  /* Update ReadAddress */
  McEthernet_ReadAddress = 0;

  /* Bank Register 1 */
  McEthernet_SetBank(BANK1);
  McEthernet_ReceivePacketNum = McEthernet_ReadRegister(EPKTCNT);

  /* Bank Register 1 */
  McEthernet_SetBank(BANK0);

  McEthernet_SetBit(ECON2, 0x40);
  while ((McEthernet_ReadRegister(EIR) & 0x40 == 0x40)) {}
  McEthernet_ClearBit(ECON2, 0x40);

  /* Receive Buffer space */
  McEthernet_WriteRegister(ERXNDL, (uint8)(0xFFF & 0x00FF));
  McEthernet_WriteRegister(ERXNDH, (uint8)(0xFFF >> 8));

  McEthernet_WriteRegister(ERXSTL, (uint8)(0x000 & 0x00FF));
  McEthernet_WriteRegister(ERXSTH, (uint8)(0x000 >> 8));
  /* Initialize read pointer */
  McEthernet_WriteRegister(ERDPTL, (uint8)((McEthernet_ReadAddress+2) & 0x00FF));
  McEthernet_WriteRegister(ERDPTH, (uint8)((McEthernet_ReadAddress+2) >> 8));


  McEthernet_WriteRegister(ERXRDPTL, (uint8)(0xFFE & 0x00FF));
  McEthernet_WriteRegister(ERXRDPTH, (uint8)(0xFFE >> 8));


  McEthernet_ReadAddress += 2;

}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function handles the read procedure for specific amount of time
 * \param McEthernet_ReadMsg read function
 * \return None
 */
void McEthernet_ReadMsg(float32 time)
{
  if (McEthernert_ReceiveMsg(time) == TRUE)
  {
    McEthernet_ReadPacket();
    McEthernet_ClearBit(ECON2, 0x40);
  }
  else
  {
    /* Report an error Here */
  }
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This function handles the read procedure
 * \param McEthernet_ReadMsg read function
 * \return boolean
 */
void McEthernet_ReadMsgInf(void)
{
  if (McEthernet_ReceiveMsgInf() == TRUE)
  {
    McEthernet_ReadPacket();
  }
  else
  {
    /* Report an error Here */
  }
}



/** \brief Update internal data when incremental mode is using T2.\n
 * This McEthernet Write Microchip Ethernet function
 * \param McEthernet_WriteRegister write function
 * \return boolean
 */
static void McEthernet_WriteRegister(uint8 Register, uint8 Command)
{
  uint8 SpiBuffer[2] = {(MC_ETHERNET_WRITECOMMAND<<5) |Register, Command};
  Spi_WriteBytes(&McEthernetChannel, SpiBuffer, 2);
}


/** \brief Update internal data when incremental mode is using T2.\n
 * This McEthernet Reads Microchip Ethernet Register function
 * \param McEthernet_ReadRegister read function
 * \return boolean
 */
static uint8 McEthernet_ReadRegister(uint8 Register)
{
  uint8 SpiBuffer = (MC_ETHERNET_READCOMMAND<<5) |Register;
  Spi_ReadRegister(&McEthernetChannel, SpiBuffer, &McEthernet_RxBuffer[0], 1);
  return McEthernet_RxBuffer[0];
}

static void McEthernet_WriteBuffer(uint8* Command, uint16 CommandSize)
{
  uint8 SpiBuffer[CommandSize+1];
  SpiBuffer[0] = MC_ETHERNET_WRITEBUFFER;
  for(uint8 i = 0; i < CommandSize; i++)
  {
    SpiBuffer[i+1] = Command[i];
  }
  Spi_WriteBytes(&McEthernetChannel, SpiBuffer, CommandSize+1);
}

static void McEthernet_ReadBuffer(uint8* Result ,uint16 ResultSize)
{
  uint8 SpiBuffer = MC_ETHERNET_READBUFFER;
  Spi_ReadBytes(&McEthernetChannel, &SpiBuffer, 1, Result, ResultSize);
}

static void McEthernet_SetBit(uint8 Register, uint8 Mask)
{
  uint8 SpiBuffer[2] = {(MC_ETHERNET_SETBIT<<5)|Register, Mask};
  Spi_WriteBytes(&McEthernetChannel, SpiBuffer, 2);
}

static void McEthernet_ClearBit(uint8 Register, uint8 Mask)
{
  uint8 SpiBuffer[2] = {(MC_ETHERNET_CLEARBIT<<5)|Register, Mask};
  Spi_WriteBytes(&McEthernetChannel, SpiBuffer, 2);
}

static void McEthernet_SetBank(uint8 Bank)
{
  uint8 ECON1reg = 0;
  switch (Bank)
  {
    case 0:
      ECON1reg = McEthernet_ReadRegister(ECON1);
      ECON1reg = (ECON1reg & 0xFC) | 0x0;
      McEthernet_WriteRegister(ECON1, ECON1reg);
      break;

    case 1:
      ECON1reg = McEthernet_ReadRegister(ECON1);
      ECON1reg = (ECON1reg & 0xFC) | 0x1;
      McEthernet_WriteRegister(ECON1, ECON1reg);
      break;

    case 2:
      ECON1reg = McEthernet_ReadRegister(ECON1);
      ECON1reg = (ECON1reg & 0xFC) | 0x2;
      McEthernet_WriteRegister(ECON1, ECON1reg);
      break;

    case 3:
      ECON1reg = McEthernet_ReadRegister(ECON1);
      ECON1reg = (ECON1reg & 0xFC) | 0x3;
      McEthernet_WriteRegister(ECON1, ECON1reg);
      break;

    default:
      ECON1reg = McEthernet_ReadRegister(ECON1);
      ECON1reg = (ECON1reg & 0xFC) | 0x0;
      McEthernet_WriteRegister(ECON1, ECON1reg);
      break;
  }
}
