/**********************************************************************************************************************
 * \file SPI_NRF24.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SPI_NRF24.h"
#include "Bsp.h"
#include "stdlib.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RH_NRF24_MAX_PAYLOAD_LEN 32

// The length of the headers we add.
// The headers are inside the nRF24 payload
#define RH_NRF24_HEADER_LEN 4

// This is the maximum RadioHead user message length that can be supported by this library. Limited by
// the supported message lengths in the nRF24
#define RH_NRF24_MAX_MESSAGE_LEN (RH_NRF24_MAX_PAYLOAD_LEN-RH_NRF24_HEADER_LEN)

// SPI Command names
#define RH_NRF24_COMMAND_R_REGISTER                        0x00
#define RH_NRF24_COMMAND_W_REGISTER                        0x20
#define RH_NRF24_COMMAND_ACTIVATE                          0x50 // only on RFM73 ?
#define RH_NRF24_COMMAND_R_RX_PAYLOAD                      0x61
#define RH_NRF24_COMMAND_W_TX_PAYLOAD                      0xa0
#define RH_NRF24_COMMAND_FLUSH_TX                          0xe1
#define RH_NRF24_COMMAND_FLUSH_RX                          0xe2
#define RH_NRF24_COMMAND_REUSE_TX_PL                       0xe3
#define RH_NRF24_COMMAND_R_RX_PL_WID                       0x60
#define RH_NRF24_COMMAND_W_ACK_PAYLOAD(pipe)               (0xa8|(pipe&0x7))
#define RH_NRF24_COMMAND_W_TX_PAYLOAD_NOACK                0xb0
#define RH_NRF24_COMMAND_NOP                               0xff

// Register names
#define RH_NRF24_REGISTER_MASK                             0x1f
#define RH_NRF24_REG_00_CONFIG                             0x00
#define RH_NRF24_REG_01_EN_AA                              0x01
#define RH_NRF24_REG_02_EN_RXADDR                          0x02
#define RH_NRF24_REG_03_SETUP_AW                           0x03
#define RH_NRF24_REG_04_SETUP_RETR                         0x04
#define RH_NRF24_REG_05_RF_CH                              0x05
#define RH_NRF24_REG_06_RF_SETUP                           0x06
#define RH_NRF24_REG_07_STATUS                             0x07
#define RH_NRF24_REG_08_OBSERVE_TX                         0x08
#define RH_NRF24_REG_09_RPD                                0x09
#define RH_NRF24_REG_0A_RX_ADDR_P0                         0x0a
#define RH_NRF24_REG_0B_RX_ADDR_P1                         0x0b
#define RH_NRF24_REG_0C_RX_ADDR_P2                         0x0c
#define RH_NRF24_REG_0D_RX_ADDR_P3                         0x0d
#define RH_NRF24_REG_0E_RX_ADDR_P4                         0x0e
#define RH_NRF24_REG_0F_RX_ADDR_P5                         0x0f
#define RH_NRF24_REG_10_TX_ADDR                            0x10
#define RH_NRF24_REG_11_RX_PW_P0                           0x11
#define RH_NRF24_REG_12_RX_PW_P1                           0x12
#define RH_NRF24_REG_13_RX_PW_P2                           0x13
#define RH_NRF24_REG_14_RX_PW_P3                           0x14
#define RH_NRF24_REG_15_RX_PW_P4                           0x15
#define RH_NRF24_REG_16_RX_PW_P5                           0x16
#define RH_NRF24_REG_17_FIFO_STATUS                        0x17
#define RH_NRF24_REG_1C_DYNPD                              0x1c
#define RH_NRF24_REG_1D_FEATURE                            0x1d

// These register masks etc are named wherever possible
// corresponding to the bit and field names in the nRF24L01 Product Specification
// #define RH_NRF24_REG_00_CONFIG                             0x00
#define RH_NRF24_MASK_RX_DR                                0x40
#define RH_NRF24_MASK_TX_DS                                0x20
#define RH_NRF24_MASK_MAX_RT                               0x10
#define RH_NRF24_EN_CRC                                    0x08
#define RH_NRF24_CRCO                                      0x04
#define RH_NRF24_PWR_UP                                    0x02
#define RH_NRF24_PRIM_RX                                   0x01

// #define RH_NRF24_REG_01_EN_AA                              0x01
#define RH_NRF24_ENAA_P5                                   0x20
#define RH_NRF24_ENAA_P4                                   0x10
#define RH_NRF24_ENAA_P3                                   0x08
#define RH_NRF24_ENAA_P2                                   0x04
#define RH_NRF24_ENAA_P1                                   0x02
#define RH_NRF24_ENAA_P0                                   0x01

// #define RH_NRF24_REG_02_EN_RXADDR                          0x02
#define RH_NRF24_ERX_P5                                    0x20
#define RH_NRF24_ERX_P4                                    0x10
#define RH_NRF24_ERX_P3                                    0x08
#define RH_NRF24_ERX_P2                                    0x04
#define RH_NRF24_ERX_P1                                    0x02
#define RH_NRF24_ERX_P0                                    0x01

// #define RH_NRF24_REG_03_SETUP_AW                           0x03
#define RH_NRF24_AW_3_BYTES                                0x01
#define RH_NRF24_AW_4_BYTES                                0x02
#define RH_NRF24_AW_5_BYTES                                0x03

// #define RH_NRF24_REG_04_SETUP_RETR                         0x04
#define RH_NRF24_ARD                                       0xf0
#define RH_NRF24_ARC                                       0x0f

// #define RH_NRF24_REG_05_RF_CH                              0x05
#define RH_NRF24_RF_CH                                     0x7f

// #define RH_NRF24_REG_06_RF_SETUP                           0x06
#define RH_NRF24_CONT_WAVE                                 0x80
#define RH_NRF24_RF_DR_LOW                                 0x20
#define RH_NRF24_PLL_LOCK                                  0x10
#define RH_NRF24_RF_DR_HIGH                                0x08
#define RH_NRF24_PWR                                       0x06
#define RH_NRF24_PWR_m18dBm                                0x00
#define RH_NRF24_PWR_m12dBm                                0x02
#define RH_NRF24_PWR_m6dBm                                 0x04
#define RH_NRF24_PWR_0dBm                                  0x06
#define RH_NRF24_LNA_HCURR                                 0x01

// #define RH_NRF24_REG_07_STATUS                             0x07
#define RH_NRF24_RX_DR                                     0x40
#define RH_NRF24_TX_DS                                     0x20
#define RH_NRF24_MAX_RT                                    0x10
#define RH_NRF24_RX_P_NO                                   0x0e
#define RH_NRF24_STATUS_TX_FULL                            0x01

// #define RH_NRF24_REG_08_OBSERVE_TX                         0x08
#define RH_NRF24_PLOS_CNT                                  0xf0
#define RH_NRF24_ARC_CNT                                   0x0f

// #define RH_NRF24_REG_09_RPD                                0x09
#define RH_NRF24_RPD                                       0x01

// #define RH_NRF24_REG_17_FIFO_STATUS                        0x17
#define RH_NRF24_TX_REUSE                                  0x40
#define RH_NRF24_TX_FULL                                   0x20
#define RH_NRF24_TX_EMPTY                                  0x10
#define RH_NRF24_RX_FULL                                   0x02
#define RH_NRF24_RX_EMPTY                                  0x01

// #define RH_NRF24_REG_1C_DYNPD                              0x1c
#define RH_NRF24_DPL_ALL                                   0x3f
#define RH_NRF24_DPL_P5                                    0x20
#define RH_NRF24_DPL_P4                                    0x10
#define RH_NRF24_DPL_P3                                    0x08
#define RH_NRF24_DPL_P2                                    0x04
#define RH_NRF24_DPL_P1                                    0x02
#define RH_NRF24_DPL_P0                                    0x01

// #define RH_NRF24_REG_1D_FEATURE                            0x1d
#define RH_NRF24_EN_DPL                                    0x04
#define RH_NRF24_EN_ACK_PAY                                0x02
#define RH_NRF24_EN_DYN_ACK                                0x01
#define SPI_BUFFER_SIZE 32
#define ISR_PRIORITY_MASTER_TX      50
#define ISR_PRIORITY_MASTER_RX      51
#define ISR_PRIORITY_MASTER_ER      52
#define MASTER_CHANNEL_BAUDRATE     10000000
#define QSPI1_MASTER                &MODULE_QSPI1
#define Delay_spi                       100

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint8 configuration = RH_NRF24_EN_CRC | RH_NRF24_CRCO;
IfxQspi_SpiMaster_Channel   spiMasterChannel;
IfxQspi_SpiMaster   spiMaster;
uint8 spiTxBuffer[SPI_BUFFER_SIZE];       /* QSPI Master Transmit buffer   */
uint8 spiRxBuffer[SPI_BUFFER_SIZE];       /* QSPI Master Receive buffer    */

volatile RHMode NRF24_mode;
RHGenericDriver RHGeneric;
uint8 NRF24_configuration;
boolean NRF24_rxBufValid;
uint8 NRF24_bufLen;
uint8 NRF24_buf[RH_NRF24_MAX_PAYLOAD_LEN];
NRF24 nrf24;


/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
 IFX_INTERRUPT(masterTxISR, 0, ISR_PRIORITY_MASTER_TX);                  /* SPI Master ISR for transmit data         */
 IFX_INTERRUPT(masterRxISR, 0, ISR_PRIORITY_MASTER_RX);                  /* SPI Master ISR for receive data          */
 IFX_INTERRUPT(masterErISR, 0, ISR_PRIORITY_MASTER_ER);                 /* SPI Master ISR for error                 */
 void masterTxISR(void){
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrTransmit(&spiMaster);
 }

 void masterRxISR(void ){
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrReceive(&spiMaster);
 }

 void masterErISR(void){
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrError(&spiMaster);
 }

 void initQSPI1Master(void){
     IfxQspi_SpiMaster_Config spiMasterConfig;                           /* Define a Master configuration            */

         IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, QSPI1_MASTER); /* Initialize it with default values        */

         spiMasterConfig.base.mode = SpiIf_Mode_master;                      /* Configure the mode                       */

         /* Select the port pins for communication */
         const IfxQspi_SpiMaster_Pins qspi1MasterPins = {
             &IfxQspi1_SCLK_P10_2_OUT, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
             &IfxQspi1_MTSR_P10_3_OUT, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
             &IfxQspi1_MRSTA_P10_1_IN, IfxPort_InputMode_pullDown,           /* MasterReceiveSlaveTransmit pin (MISO)    */
             IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
         };
         spiMasterConfig.pins = &qspi1MasterPins;                            /* Assign the Master's port pins            */

         /* Set the ISR priorities and the service provider */
         spiMasterConfig.base.txPriority = ISR_PRIORITY_MASTER_TX;
         spiMasterConfig.base.rxPriority = ISR_PRIORITY_MASTER_RX;
         spiMasterConfig.base.erPriority = ISR_PRIORITY_MASTER_ER;
         spiMasterConfig.base.isrProvider = IfxSrc_Tos_cpu0;

         /* Initialize the QSPI Master module */
         IfxQspi_SpiMaster_initModule(&spiMaster, &spiMasterConfig);
 }
 void initQSPI1MasterChannel(void)
 {
     IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;             /* Define a Master Channel configuration    */

     /* Initialize the configuration with default values */
     IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &spiMaster);
     const IfxQspi_SpiMaster_Output qspi1SlaveSelect = {                 /* QSPI1 Master selects the QSPI3 Slave     */
         &IfxQspi1_SLSO10_P10_0_OUT, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
         IfxPort_PadDriver_cmosAutomotiveSpeed1                          /* Pad driver mode                          */
     };

     spiMasterChannelConfig.sls.output = qspi1SlaveSelect;

     spiMasterChannelConfig.base.baudrate = MASTER_CHANNEL_BAUDRATE;    /* Set SCLK frequency to 10 MHz              */
     spiMasterChannelConfig.base.mode.dataWidth = 8;        /* Set the transfer data width to 8 bits    */
     spiMasterChannelConfig.base.mode.clockPolarity = 0;
     spiMasterChannelConfig.base.mode.shiftClock = SpiIf_ShiftClock_shiftTransmitDataOnTrailingEdge;
     spiMasterChannelConfig.base.mode.dataHeading = SpiIf_DataHeading_msbFirst;
     spiMasterChannelConfig.base.mode.parityCheck = 0;
     spiMasterChannelConfig.base.mode.autoCS =0;

     /* Select the port pin for the Chip Select signal */


     /* Initialize the QSPI Master channel */
     IfxQspi_SpiMaster_initChannel(&spiMasterChannel, &spiMasterChannelConfig);
 }

 void initQSPI1MasterBuffers(void)
 {
     for (uint8 i = 0; i < SPI_BUFFER_SIZE; i++)
     {
        spiTxBuffer[i] = 0;        /* Fill TX Master Buffer with pattern       */
        spiRxBuffer[i] = 0;                     /* Clear RX Buffer                          */
     }
 }
 /* This function initialize the QSPI modules */
 void initQSPI(void)
 {
     /* Secondly initialize the Master */
     initQSPI1Master();
     initQSPI1MasterChannel();
     initQSPI1MasterBuffers();
 }

void Spi_write_register(uint8 register_val)
{
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
        // receive new stream
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &register_val, &spiRxBuffer[0], 1);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
}

uint8 Spi_write_command(uint8 command){
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    uint8 response;
            // receive new stream
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &command, &response, 1);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );

    return response;
}

void Spi_read_register(uint8 register_val,uint8 count){
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    spiTxBuffer[0] = register_val;
    spiRxBuffer[0] = 0;
    for (int i=1;i<=count+1;i++){
        spiTxBuffer[i]= 0;
        spiRxBuffer[i] = 0;
    }
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &spiTxBuffer[0], &spiRxBuffer[0], count+1);


    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
}

uint8 Spi_read(uint8 register_val){
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    spiTxBuffer[0] = register_val;
    spiRxBuffer[0] = 0;
    spiTxBuffer[1]= 0;
    spiRxBuffer[1] = 0;
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &spiTxBuffer[0], &spiRxBuffer[0], 2);


    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    return spiRxBuffer[1];
}
void Spi_BurstRead(uint8 reg, uint8* dest, uint8 len){

    Spi_read_register(reg ,len);
    for (int i=0;i<len;i++){
        dest[i] = spiRxBuffer[i+1];
    }
}

void Spi_BurstWrite(uint8 reg,uint8* address,uint8 count){
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    spiTxBuffer[0] = reg;
    for (int i=0;i<count;i++){
        spiTxBuffer[1+i] = address[i];
    }

        // send the reg and the address array
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &spiTxBuffer[0], &spiRxBuffer[0], count+1);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
}

void Spi_write_register_value(uint8 register_val,uint8 value){
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    uint8 buffer[2] = {register_val , value};

    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &buffer[0], &spiRxBuffer[0], 2);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );

}


void NRF24_spiWriteRegister(uint8 reg,uint8  val)
{
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    uint8 buffer[2] = {(reg & RH_NRF24_REGISTER_MASK) | RH_NRF24_COMMAND_W_REGISTER, val};

        // send new stream
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, buffer, &spiRxBuffer[0], 2);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
}

uint8 NRF24_spiReadRegister(uint8 reg){
    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
    reg = (reg & RH_NRF24_REGISTER_MASK) | RH_NRF24_COMMAND_R_REGISTER;
    uint8 TxBuf[2] = {reg,0};
    uint8 RxBuf[2] = {0x00,0x00};
           // receive new stream
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, TxBuf, RxBuf, 2);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );

    return RxBuf[1];
}


void NRF24_spiBurstWriteRegister(uint8 reg,uint8* address,uint8 count){
    spiTxBuffer[0] = (reg & RH_NRF24_REGISTER_MASK) | RH_NRF24_COMMAND_W_REGISTER;
    for (int i=0;i<count;i++){
        spiTxBuffer[1+i] = address[i];
    }

        // send the reg and the address array
    IfxQspi_SpiMaster_exchange(&spiMasterChannel, &spiTxBuffer[0], &spiRxBuffer[0], count+1);

    while( IfxQspi_SpiMaster_getStatus(&spiMasterChannel) == SpiIf_Status_busy );
}

void NRF24_spiBurstReadRegister(uint8 reg, uint8* dest, uint8 len){

    Spi_read_register((reg & RH_NRF24_REGISTER_MASK) | RH_NRF24_COMMAND_R_REGISTER,len);
    for (int i=0;i<len;i++){
        dest[i] = spiRxBuffer[i+1];
    }
}

boolean RHGeneric_init(void){
RHGeneric._mode = RHModeInitialising;
RHGeneric._thisAddress = RH_BROADCAST_ADDRESS;
RHGeneric._txHeaderTo = RH_BROADCAST_ADDRESS;
RHGeneric._txHeaderFrom = RH_BROADCAST_ADDRESS;
RHGeneric._txHeaderId = 0;
RHGeneric._txHeaderFlags = 0;
RHGeneric._rxBad = 0;
RHGeneric._rxGood = 0;
RHGeneric._txGood = 0;
RHGeneric._cad_timeout = 0;
return 1;
}

boolean NRF24_waitCAD(void)
{
    if (!RHGeneric._cad_timeout)
    return 1;

    // Wait for any channel activity to finish or timeout
    // Sophisticated DCF function...
    // DCF : BackoffTime = random() x aSlotTime
    // 100 - 1000 ms
    // 10 sec timeout
    uint64 t = IfxStm_get(&MODULE_STM0);
    Ifx_TickTime cad_timeout = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,(uint32)RHGeneric._cad_timeout);
    while (0)
    {
      if (IfxStm_get(&MODULE_STM0)- t > cad_timeout){
         return 0;
         }
     Ifx_TickTime randTime =IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,((rand()&10)+1) * 100);
     wait(randTime);

    }

    return 1;
}
uint8 NRF24_statusRead()
{
    // status is a side-effect of NOP, faster than reading reg 07
    return Spi_write_command(RH_NRF24_COMMAND_NOP);
}

boolean NRF24_init(Ifx_P* cePort ,uint8 cePin){
    if (!RHGeneric_init()){
         return 0;
    }
    initQSPI();
    Ifx_TickTime delay = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,Delay_spi);
    nrf24.cePort = cePort;
    nrf24.cePinIndex = cePin;
    NRF24_rxBufValid=0;
    setPinOutput(nrf24.cePort,nrf24.cePinIndex);
    setPinOutputTrue(nrf24.cePort,nrf24.cePinIndex);
    wait(delay);
    setPinOutputFalse(nrf24.cePort,nrf24.cePinIndex);
    NRF24_configuration = RH_NRF24_EN_CRC | RH_NRF24_CRCO;
    NRF24_spiWriteRegister(RH_NRF24_REG_07_STATUS,(RH_NRF24_RX_DR | RH_NRF24_TX_DS | RH_NRF24_MAX_RT));
    NRF24_spiWriteRegister(RH_NRF24_REG_1C_DYNPD,RH_NRF24_DPL_ALL);
    NRF24_spiWriteRegister(RH_NRF24_REG_1D_FEATURE,RH_NRF24_EN_DPL | RH_NRF24_EN_DYN_ACK);
    if (NRF24_spiReadRegister(RH_NRF24_REG_1D_FEATURE)!=(RH_NRF24_EN_DPL | RH_NRF24_EN_DYN_ACK)){
        Spi_write_register_value(RH_NRF24_COMMAND_ACTIVATE,0x73);
        NRF24_spiWriteRegister(RH_NRF24_REG_1D_FEATURE,RH_NRF24_EN_DPL | RH_NRF24_EN_DYN_ACK);
        if (NRF24_spiReadRegister(RH_NRF24_REG_1D_FEATURE)!=(RH_NRF24_EN_DPL | RH_NRF24_EN_DYN_ACK)){
            return 0;
        }
    }
    NRF24_clearRxBuf();
    NRF24_setModeIdle(nrf24.cePort,nrf24.cePinIndex);

    NRF24_flushTx();
    NRF24_flushRx();

    NRF24_setChannel(2);
    NRF24_setRF(DataRate2Mbps,TransmitPower0dBm);
    return 1;


}

boolean NRF24_setRF(DataRate data_rate, TransmitPower power)
{
    uint8 value = (power << 1) & RH_NRF24_PWR;
    // Ugly mapping of data rates to noncontiguous 2 bits:
    if (data_rate == DataRate250kbps)
    value |= RH_NRF24_RF_DR_LOW;
    else if (data_rate == DataRate2Mbps)
    value |= RH_NRF24_RF_DR_HIGH;
    // else DataRate1Mbps, 00

    // RFM73 needs this:
    value |= RH_NRF24_LNA_HCURR;

    NRF24_spiWriteRegister(RH_NRF24_REG_06_RF_SETUP, value);
    // If we were using auto-ack, we would have to set the appropriate timeout in reg 4 here
    // see NRF24::setRF()
    return 1;
}



void NRF24_setModeIdle(Ifx_P* cePort,uint8 cePinIndex)
{
    if (NRF24_mode != RHModeIdle)
    {
    setPinOutputFalse(cePort,cePinIndex);
    NRF24_spiWriteRegister(RH_NRF24_REG_00_CONFIG, NRF24_configuration);
    NRF24_mode = RHModeIdle;
    }
}

void NRF24_setModeRx(Ifx_P* cePort,uint8 cePinIndex)
{
    if (NRF24_mode != RHModeRx)
    {
    NRF24_spiWriteRegister(RH_NRF24_REG_00_CONFIG, NRF24_configuration | RH_NRF24_PWR_UP | RH_NRF24_PRIM_RX);
    setPinOutputTrue(cePort,cePinIndex);
    NRF24_mode = RHModeRx;
    }
}

void NRF24_setModeTx(Ifx_P* cePort,uint8 cePinIndex)
{
    if (NRF24_mode != RHModeTx)
    {
    // Its the CE rising edge that puts us into TX mode
    // CE staying high makes us go to standby-II when the packet is sent
    setPinOutputFalse(cePort,cePinIndex);
    // Ensure DS is not set
    NRF24_spiWriteRegister(RH_NRF24_REG_07_STATUS, RH_NRF24_TX_DS | RH_NRF24_MAX_RT);
    NRF24_spiWriteRegister(RH_NRF24_REG_00_CONFIG, NRF24_configuration | RH_NRF24_PWR_UP);
    setPinOutputTrue(cePort,cePinIndex);
    NRF24_mode = RHModeTx;
    }
}

boolean NRF24_sleep(Ifx_P* cePort,uint8 cePinIndex)
{
    if (NRF24_mode != RHModeSleep)
    {
    NRF24_spiWriteRegister(RH_NRF24_REG_00_CONFIG, 0); // Power Down mode
    setPinOutputFalse(cePort,cePinIndex);
    NRF24_mode = RHModeSleep;
    return 1;
    }
    return 0; // Already there?
}


void NRF24_flushTx(void){
    Spi_write_register(RH_NRF24_COMMAND_FLUSH_TX);
}

void NRF24_flushRx(void)
{
    Spi_write_register(RH_NRF24_COMMAND_FLUSH_RX);
}

boolean NRF24_setChannel(uint8 channel)
{
    NRF24_spiWriteRegister(RH_NRF24_REG_05_RF_CH, channel & RH_NRF24_RF_CH);
    return 1;
}

boolean NRF24_setOpMode(uint8 mode)
{
    NRF24_configuration = mode;
    return 1;
}

boolean NRF24_setNetworkAddress(uint8* address, uint8 len)
{
    if (len < 3 || len > 5)
    return 0;

    // Set both TX_ADDR and RX_ADDR_P0 for auto-ack with Enhanced shockwave
    NRF24_spiWriteRegister(RH_NRF24_REG_03_SETUP_AW, len-2);  // Mapping [3..5] = [1..3]
    NRF24_spiBurstWriteRegister(RH_NRF24_REG_0A_RX_ADDR_P0, address, len);
    NRF24_spiBurstWriteRegister(RH_NRF24_REG_10_TX_ADDR, address, len);
    return 1;
}


boolean NRF24_send(const uint8* data, uint8 len)
{
    if (len > RH_NRF24_MAX_MESSAGE_LEN)
    return 0;

    if (!NRF24_waitCAD())
    return 0;  // Check channel activity

    // Set up the headers
    NRF24_buf[0] = RHGeneric._txHeaderTo;
    NRF24_buf[1] = RHGeneric._txHeaderFrom;
    NRF24_buf[2] = RHGeneric._txHeaderId;
    NRF24_buf[3] = RHGeneric._txHeaderFlags;
    for (int i=0;i<len;i++){
        NRF24_buf[i+RH_NRF24_HEADER_LEN] = data[i];
    }
    Spi_BurstWrite(RH_NRF24_COMMAND_W_TX_PAYLOAD_NOACK, NRF24_buf, len + RH_NRF24_HEADER_LEN);
    NRF24_setModeTx(nrf24.cePort,nrf24.cePinIndex);
    // Radio will return to Standby II mode after transmission is complete
    RHGeneric._txGood++;
    return 1;
}

boolean NRF24_waitPacketSent(void)
{
    // If we are not currently in transmit mode, there is no packet to wait for
    if (NRF24_mode != RHModeTx)
    return 0;

    // Wait for either the Data Sent or Max ReTries flag, signalling the
    // end of transmission
    // We dont actually use auto-ack, so prob dont expect to see RH_NRF24_MAX_RT
    uint8 status;
    uint64 start = IfxStm_get(&MODULE_STM0);
    Ifx_TickTime timeout_val = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER,100);
    while (!((status = NRF24_statusRead()) & (RH_NRF24_TX_DS | RH_NRF24_MAX_RT)))
    {
    if ((IfxStm_get(&MODULE_STM0) - start) > timeout_val) // Longer than any possible message
        break;  // Should never happen: TX never completed. Why?
    }

    // Must clear RH_NRF24_MAX_RT if it is set, else no further comm
    if (status & RH_NRF24_MAX_RT)
    NRF24_flushTx();
    NRF24_setModeIdle(nrf24.cePort,nrf24.cePinIndex);
    NRF24_spiWriteRegister(RH_NRF24_REG_07_STATUS, RH_NRF24_TX_DS | RH_NRF24_MAX_RT);
    // Return true if data sent, false if MAX_RT
    return status & RH_NRF24_TX_DS;
}

boolean RH_NRF24_isSending(void)
{
    return !(NRF24_spiReadRegister(RH_NRF24_REG_00_CONFIG) & RH_NRF24_PRIM_RX) &&
       !(NRF24_statusRead() & (RH_NRF24_TX_DS | RH_NRF24_MAX_RT));
}

void NRF24_validateRxBuf(void)
{
    if (NRF24_bufLen < 4)
    return; // Too short to be a real message
    // Extract the 4 headers
    RHGeneric._rxHeaderTo    = NRF24_buf[0];
    RHGeneric._rxHeaderFrom  = NRF24_buf[1];
    RHGeneric._rxHeaderId    = NRF24_buf[2];
    RHGeneric._rxHeaderFlags = NRF24_buf[3];
    if (RHGeneric._promiscuous ||
            RHGeneric._rxHeaderTo == RHGeneric._thisAddress ||
            RHGeneric._rxHeaderTo == RH_BROADCAST_ADDRESS)
    {
        RHGeneric._rxGood++;
        NRF24_rxBufValid = 1;
    }
}

boolean NRF24_available(void)
{
    if (!NRF24_rxBufValid)
    {
    if (NRF24_mode == RHModeTx)
        return 0;
    NRF24_setModeRx(nrf24.cePort,nrf24.cePinIndex);
    if (NRF24_spiReadRegister(RH_NRF24_REG_17_FIFO_STATUS) & RH_NRF24_RX_EMPTY)
        return 0;
    // Manual says that messages > 32 octets should be discarded
    uint8 len = Spi_read(RH_NRF24_COMMAND_R_RX_PL_WID);
    if (len > 32)
    {
        NRF24_flushRx();
        NRF24_clearRxBuf();
        NRF24_setModeIdle(nrf24.cePort,nrf24.cePinIndex);
        return 0;
    }
    // Clear read interrupt
    NRF24_spiWriteRegister(RH_NRF24_REG_07_STATUS, RH_NRF24_RX_DR);
    // Get the message into the RX buffer, so we can inspect the headers
    Spi_BurstRead(RH_NRF24_COMMAND_R_RX_PAYLOAD, NRF24_buf, len);
    NRF24_bufLen = len;
    // 140 microsecs (32 octet payload)
    NRF24_validateRxBuf();
    if (NRF24_rxBufValid)
        NRF24_setModeIdle(nrf24.cePort,nrf24.cePinIndex); // Got one
    }
    return NRF24_rxBufValid;
}

boolean NRF24_recv(uint8* buf, uint8* len)
{
    if (!NRF24_available())
    return 0;
    if (buf && len)
    {
    // Skip the 4 headers that are at the beginning of the rxBuf
    if (*len > NRF24_bufLen-RH_NRF24_HEADER_LEN)
        *len = NRF24_bufLen-RH_NRF24_HEADER_LEN;
        for (int i=0;i<*len;i++){
            buf[i] = NRF24_buf[RH_NRF24_HEADER_LEN+i];
        }
    }
    NRF24_clearRxBuf(); // This message accepted and cleared
    return 1;
}

uint8 NRF24_maxMessageLength()
{
    return RH_NRF24_MAX_MESSAGE_LEN;
}


void NRF24_clearRxBuf(void)
{
    NRF24_rxBufValid = 0;
    NRF24_bufLen = 0;
}


