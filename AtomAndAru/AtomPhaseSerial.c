
/**********************************************************************************************************************
 * \file phaseShiftPwm.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "../InfineonArduinoLike/AtomAndAru/AtomPhaseSerial.h"
#include "../InfineonArduinoLike/Dma.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define MAX_ATOM_CHANNELS           4
#define  MOSI_CHANNELS              3
#define MASTER_TIMER_ISR            18
#define QUAD_SPI_DMA_ISR            16
#define ATOM_BITSHIFT               15
#define QUAD_SPI_BUFFER_SIZE        128
#define QAUD_SPI_FILLLEVEL          64



/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Structure for three phase PWM output configuration and handling */
typedef struct
{
    IfxGtm_Atom_Timer    timer;                  /* Timer driver                                                      */
    IfxGtm_Atom_PwmHl    pwm;                    /* GTM TOM PWM driver object                                         */
    Ifx_TimerValue      pwmOnTimes[3];          /* PWM ON-time for 3 phases                                          */
    IfxGtm_Atom_Serial  update;
    IfxGtm_Atom_Timer   SpiClk;
    uint32              spiPeriod;
} Serial_Timers_Output;


static Serial_Timers_Output AtomPhaseSerial_Output;

volatile boolean AtomPhaseSerial_SpiEnd = TRUE;


static uint8 AtomPhaseSerial_RingBufferSize = 0;

IfxDma_Dma_Channel AtomPhaseSerial_DmaChannel[MOSI_CHANNELS];

IfxDma_Dma_Channel AtomPhaseSerial_DataChannel[MOSI_CHANNELS];

static uint16 AtomPhaseSerial_TxSpiBuffer_Ch1[QUAD_SPI_BUFFER_SIZE];
static uint16 AtomPhaseSerial_TxSpiBuffer_Ch2[QUAD_SPI_BUFFER_SIZE];
static uint16 AtomPhaseSerial_TxSpiBuffer_Ch3[QUAD_SPI_BUFFER_SIZE];

static ATOMPHASESERIAL_SPIBUFFER AtomPhaseSerial_TxBuffer[MOSI_CHANNELS] =
{
    AtomPhaseSerial_TxSpiBuffer_Ch1,
    AtomPhaseSerial_TxSpiBuffer_Ch2,
    AtomPhaseSerial_TxSpiBuffer_Ch3
};

ATOMPHASESERIAL_RINGBUFFER AtomPhaseSerial_Buffer =
{
    AtomPhaseSerial_TxBuffer,
    &AtomPhaseSerial_RingBufferSize
};

static ATOMPHASESERIAL_MOSIREGS AtomPhaseSerial_MosiChannels[MOSI_CHANNELS] =
{
    NULL_PTR,
    NULL_PTR,
    NULL_PTR
};

static ATOMPHASESERIAL_MOSIREGS AtomPhaseSerial_ChipSelect = NULL_PTR;


volatile uint32 AtomPhaseSerial_DataRemain = 0;
volatile uint8 AtomPhaseSerial_DataIndex = 0;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
IFX_STATIC void IfxGtmAtomSerialUpdate(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(AtomPhaseSerial_Isr,0, MASTER_TIMER_ISR);
void AtomPhaseSerial_Isr(void)
{
  IfxGtm_Atom_Timer_acknowledgeTimerIrq(&AtomPhaseSerial_Output.timer);
  if (!AtomPhaseSerial_SpiEnd)
  {
    switch (AtomPhaseSerial_DataRemain)
    {
      default:
      {
        IfxDma_startChannelTransaction(AtomPhaseSerial_DataChannel[0].dma,
                                       AtomPhaseSerial_DataChannel[0].channelId);
        AtomPhaseSerial_DataRemain--;
        break;
      }

      case 0:
      {
        /* Prepare the chip select */
        AtomPhaseSerial_ChipSelect->SR1.U = 0xFFFF;
        for (uint8 i = 0; i < MOSI_CHANNELS; i++)
        {
          AtomPhaseSerial_MosiChannels[i]->SR1.U = 0;
        }
        AtomPhaseSerial_SpiEnd = TRUE;
        break;
      }
    }
  }
  else
  {
    IfxGtm_Atom_Timer_stop(&AtomPhaseSerial_Output.SpiClk);
    IfxGtm_Atom_Timer_stop(&AtomPhaseSerial_Output.timer);
  }

}


IFX_INTERRUPT(AtomPhaseSerial_DmaIsr, 0, QUAD_SPI_DMA_ISR);
void AtomPhaseSerial_DmaIsr(void)
{
  /* Enable global Interrupts   */
  IfxCpu_enableInterrupts();
  /* Prepare the chip select */
  AtomPhaseSerial_ChipSelect->SR1.U = 0x0;
  IfxDma_startChannelTransaction(AtomPhaseSerial_DataChannel[0].dma,
                                     AtomPhaseSerial_DataChannel[0].channelId);
  AtomPhaseSerial_DataIndex++;
  AtomPhaseSerial_DataRemain--;
  IfxGtm_Atom_Timer_disableUpdate(&AtomPhaseSerial_Output.SpiClk);
  IfxGtm_Atom_Timer_disableUpdate(&AtomPhaseSerial_Output.timer);
  AtomPhaseSerial_SpiEnd =  FALSE;
  IfxGtm_Atom_Timer_run(&AtomPhaseSerial_Output.timer);
  IfxGtm_Atom_Timer_run(&AtomPhaseSerial_Output.SpiClk);
  IfxGtm_Atom_Timer_applyUpdate(&AtomPhaseSerial_Output.SpiClk);
  IfxGtm_Atom_Timer_applyUpdate(&AtomPhaseSerial_Output.timer);
}


IFX_STATIC void IfxGtmAtomSerialSetSpiClk(IfxGtm_Atom_ToutMap* SpiPin, IfxGtm_Cmu_Clk Clock, uint32 frequency)
{
  IfxGtm_Atom_Timer_Config atomConfig;

  atomConfig.base.frequency                  = (float32)frequency;
  atomConfig.base.isrPriority                = 0;
  atomConfig.base.isrProvider                = IfxSrc_Tos_cpu0;
  atomConfig.base.minResolution              = 0;
  atomConfig.base.trigger.outputMode         = IfxPort_OutputMode_pushPull;
  atomConfig.base.trigger.outputDriver       = IfxPort_PadDriver_cmosAutomotiveSpeed1;
  atomConfig.base.trigger.risingEdgeAtPeriod = TRUE;
  atomConfig.base.trigger.outputEnabled      = TRUE;
  atomConfig.base.trigger.enabled            = TRUE;
  atomConfig.base.trigger.triggerPoint       = 1;
  atomConfig.base.trigger.isrPriority        = 0;
  atomConfig.base.trigger.isrProvider        = IfxSrc_Tos_cpu0;
  atomConfig.base.countDir                   = IfxStdIf_Timer_CountDir_up;
  atomConfig.base.startOffset                = 0.0;
  atomConfig.gtm            = &MODULE_GTM;
  atomConfig.atom           = SpiPin->atom;
  atomConfig.timerChannel   = SpiPin->channel-1;
  atomConfig.triggerOut     = SpiPin;
  atomConfig.clock          = Clock;
  atomConfig.base.countDir  = IfxStdIf_Timer_CountDir_up;
  atomConfig.irqModeTimer   = IfxGtm_IrqMode_level;
  atomConfig.irqModeTrigger = IfxGtm_IrqMode_pulseNotify;
  atomConfig.initPins       = TRUE;

  IfxGtm_Atom_Timer_init(&AtomPhaseSerial_Output.SpiClk, &atomConfig);
  /* Get the Spi Period */
  IfxGtm_Atom_Timer_disableUpdate(&AtomPhaseSerial_Output.SpiClk);
  AtomPhaseSerial_Output.spiPeriod = IfxGtm_Atom_Ch_getCompareZero(AtomPhaseSerial_Output.SpiClk.atom, AtomPhaseSerial_Output.SpiClk.triggerChannel);
  IfxGtm_Atom_Ch_setCompareShadow(AtomPhaseSerial_Output.SpiClk.atom, AtomPhaseSerial_Output.SpiClk.triggerChannel,
    (3*AtomPhaseSerial_Output.spiPeriod) >> 2, AtomPhaseSerial_Output.spiPeriod >> 2);
    IfxGtm_Atom_Timer_applyUpdate(&AtomPhaseSerial_Output.SpiClk);
  IfxGtm_Atom_Timer_applyUpdate(&AtomPhaseSerial_Output.SpiClk); /* Enable the update of SpiClock Timer */
}


/*This function sets default pwm signals for every phase*/
IFX_STATIC void IfxGtmAtomSerialUpdateOff(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
  IFX_UNUSED_PARAMETER(tOn)
  uint8 ChannelIndex;

  for (ChannelIndex = 0; ChannelIndex < driver->base.channelCount; ChannelIndex++)
  {
    IfxGtm_Atom_Ch_setCompareOneShadow(driver->atom, driver->ccxTemp[ChannelIndex],
          0);
  }
}


IFX_STATIC void IfxGtmAtomSerialUpdatePeriod(IfxGtm_Atom_PwmHl *driver)
{
  uint8 ChannelIndex;
  for (ChannelIndex = 0; ChannelIndex < driver->base.channelCount; ChannelIndex++)
  {
    IfxGtm_Atom_Ch_setCompareZeroShadow(driver->atom, driver->ccxTemp[ChannelIndex],
        ATOM_BITSHIFT);
  }
}

/*This function runs the function pointer of the AtomPhaseSerial_Output.update structure and sets the dutycycle of the pwm signals*/
void IfxGtm_AtomSerialThreeTimersSetOnTime(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    AtomPhaseSerial_Output.update.setMode(driver, tOn);
}


/*This function Starts the three phase pwm signals*/
IFX_STATIC void IfxGtmAtomSerialUpdate(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
  uint8          channelIndex;
  Ifx_TimerValue period;

  period = driver->timer->base.period;

  for (channelIndex = 1; channelIndex < driver->base.channelCount; channelIndex++)
  {
    IfxGtm_Atom_Ch_setCompareOneShadow(driver->atom, driver->ccxTemp[channelIndex],
        tOn[channelIndex] << 6);
  }
}

/*This pointer of structures has the different modes of the three phase signals, at first we use the configuration of
 * IfxGtmAtomSerialchModes[1] structure and then the configuration of IfxGtmAtomSerialchModes[0] structure*/
IFX_STATIC IFX_CONST IfxGtm_Atom_Serial IfxGtmAtomSerialchModes[2] = {
    {Ifx_Pwm_Mode_centerAligned,         FALSE, &IfxGtmAtomSerialUpdate  },
    {Ifx_Pwm_Mode_off,                   FALSE, &IfxGtmAtomSerialUpdateOff   }
    /*To add two more modes*/
};


IFX_STATIC void IfxGtmAtomStoreSrRegs(IfxGtm_Atom_PwmHl *driver)
{
  /* Get the Chip Select Register */
  AtomPhaseSerial_ChipSelect = IfxGtm_Atom_Ch_getChannelPointer(driver->atom, driver->ccx[0]);

  /* Get the Mosi Registers */
  for(uint8 channelIndex = 1; channelIndex < driver->base.channelCount; channelIndex++)
  {
    AtomPhaseSerial_MosiChannels[channelIndex - 1] = IfxGtm_Atom_Ch_getChannelPointer(driver->atom, driver->ccx[channelIndex]);
  }
}


/*This function sets the mode of the three phase pwm signals*/
boolean IfxGtm_AtomSerialThreeTimersSetMode(IfxGtm_Atom_PwmHl *driver, Ifx_Pwm_Mode mode)
{
    boolean                Result = TRUE;
    IfxGtm_Atom_PwmHl_Base *Base   = &driver->base;
    IfxGtm_Atom_Ch Channel;

    if (Base->mode != mode)
    {
        if (mode > Ifx_Pwm_Mode_off)
        {
            mode = Ifx_Pwm_Mode_off;
            Result = FALSE;
        }

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, mode == IfxGtm_Atom_Pwmccx_modes[mode].mode);

        Base->mode             = mode;
        AtomPhaseSerial_Output.update         = IfxGtmAtomSerialchModes[0];

            driver->ccxTemp   = driver->ccx;

        {   /* Workaround to enable the signal inversion required for center aligned inverted
             * and right aligned modes */
            /** \note that changing signal level may produce short circuit at the power stage,
             * in which case the inverter must be disable during this action. */

            /* Ifx_Pwm_Mode_centerAligned and Ifx_Pwm_Mode_LeftAligned use inverted=FALSE */
            /* Ifx_Pwm_Mode_centerAlignedInverted and Ifx_Pwm_Mode_RightAligned use inverted=TRUE */
            uint32 ChannelIndex;

            for (ChannelIndex = 0; ChannelIndex < driver->base.channelCount; ChannelIndex++)
            {

                Channel = driver->ccx[ChannelIndex];
                IfxGtm_Atom_Ch_setSignalLevel(driver->atom, Channel, Base->ccxActiveState); /*Every phase must have the same signal level, active state high*/
            }
        }
    }

    return Result;
}



/*This function returns true when the three timers are initialized correctly*/
boolean IfxGtm_AtomSerialChannelsInit(IfxGtm_Atom_PwmHl *driver, IfxGtm_Atom_PwmHl_Config *config) {
    boolean           Result = TRUE;
    uint16            ChannelMask;
    uint16            ChannelsMask = 0;
    uint32            ChannelIndex;
    IfxGtm_Atom_Timer  *Timer        = config->timer;

    driver->base.mode             = Ifx_Pwm_Mode_init;
    driver->timer                 = Timer;
    driver->base.setMode          = 0;
    driver->base.inverted         = FALSE;
    driver->base.ccxActiveState   = config->base.ccxActiveState; /*Gets the active state of pwm signals from the configuration struct*/
    driver->base.channelCount     = config->base.channelCount; /*Gets the max channel count of controlled pwm signals by the master timer*/


    driver->atom = &(Timer->gtm->ATOM[config->atom]); /*Gets the Tom used as master*/

    /* config->ccx[0] is used for the definition of the TGC */
    driver->agc = (Ifx_GTM_ATOM_AGC *)&driver->atom->AGC.GLB_CTRL; /*In case we have channels from 0-6 we enable global control register 0*/


    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, config->base.channelCount <=MAX_ATOM_CHANNELS); /*In case we have less than 2 controlled pwm signals return 0*/

    IfxGtm_Cmu_Clk Clock = IfxGtm_Atom_Ch_getClockSource(Timer->atom, Timer->timerChannel); /*Set prescaler for every phase*/

    for (ChannelIndex = 0; ChannelIndex < config->base.channelCount; ChannelIndex++)
    {
        IfxGtm_Atom_Ch Channel;
        /* CCX */
        Channel                   = config->ccx[ChannelIndex]->channel;
        driver->ccx[ChannelIndex] = Channel;
        ChannelMask               = 1 << (Channel);
        ChannelsMask             |= ChannelMask;

        /* Initialize the timer part */
        IfxGtm_Atom_Ch_configureOutputSerial(driver->atom, Channel, Clock,
            driver->base.ccxActiveState, FALSE);

        /* Initialize the port */
        if (config->initPins == TRUE)
        {
            IfxGtm_PinMap_setAtomTout(config->ccx[ChannelIndex],
                config->base.outputMode, config->base.outputDriver);
        }
    }
    IfxGtm_Atom_Agc_enableChannelsOutput(driver->agc, ChannelsMask, 0, TRUE);
    IfxGtm_Atom_Agc_enableChannels(driver->agc, ChannelsMask, 0, TRUE);


    IfxGtm_AtomSerialThreeTimersSetMode(driver, Ifx_Pwm_Mode_off); /*Enable the timers by having zero dutycycle*/

    Ifx_TimerValue tOn[MAX_ATOM_CHANNELS] = {0xFFFF, 0x0, 0x0, 0x0};
    IfxGtmAtomSerialUpdateOff(driver, tOn);     /* tOn do not need defined values */
    /* Transfer the shadow registers */
    IfxGtm_Atom_Agc_setChannelsForceUpdate(driver->agc, ChannelsMask, 0, 0, 0);
    IfxGtm_Atom_Agc_trigger(driver->agc);
    IfxGtm_Atom_Agc_setChannelsForceUpdate(driver->agc, 0, ChannelsMask, 0, 0);

    /* Enable timer to update the channels */
    for (ChannelIndex = 0; ChannelIndex < driver->base.channelCount; ChannelIndex++)
    {
        IfxGtm_Atom_Timer_addToChannelMask(Timer, driver->ccx[ChannelIndex]);
    }

    IfxGtmAtomStoreSrRegs(driver);

    /* Here we set up the daisy chain dma channels */
    AtomPhaseSerial_DataChannel[0].channelId = IfxDma_ChannelId_10;
    Dma_InitDaisyChainMaster(&AtomPhaseSerial_DataChannel[0], 1, (uint32)(&AtomPhaseSerial_TxSpiBuffer_Ch1[0]),
        (uint32)(&AtomPhaseSerial_MosiChannels[0]->SR1.U), 0,IfxDma_ChannelIncrementCircular_256,
        IfxDma_ChannelIncrementCircular_none, IfxDma_ChannelMoveSize_16bit);

    AtomPhaseSerial_DataChannel[1].channelId = IfxDma_ChannelId_9;
    Dma_InitDaisyChain(&AtomPhaseSerial_DataChannel[1], 1, (uint32)(&AtomPhaseSerial_TxSpiBuffer_Ch2[0]),
        (uint32)(&AtomPhaseSerial_MosiChannels[1]->SR1.U), 0,IfxDma_ChannelIncrementCircular_256,
        IfxDma_ChannelIncrementCircular_none, IfxDma_ChannelMoveSize_16bit);

    AtomPhaseSerial_DataChannel[2].channelId = IfxDma_ChannelId_8;
    Dma_InitDaisyChain(&AtomPhaseSerial_DataChannel[2], 1, (uint32)(&AtomPhaseSerial_TxSpiBuffer_Ch3[0]),
        (uint32)(&AtomPhaseSerial_MosiChannels[2]->SR1.U), 0,IfxDma_ChannelIncrementCircular_256,
        IfxDma_ChannelIncrementCircular_none, IfxDma_ChannelMoveSize_16bit);

    return Result;
}


/* Initialization of the dma channels for the fifo channels */
static void AruPhaseSerial_DmaInit(ATOMPHASESERIAL_INPUTBUFFER* Message)
{

  /* Initialization of the Dma Fifo 2 channel */
  AtomPhaseSerial_DmaChannel[0].channelId = (IfxDma_ChannelId)0;
  AtomPhaseSerial_DmaChannel[1].channelId = (IfxDma_ChannelId)1;
  AtomPhaseSerial_DmaChannel[2].channelId = (IfxDma_ChannelId)2;

  Dma_Init(&AtomPhaseSerial_DmaChannel[0], QUAD_SPI_BUFFER_SIZE >> 2, (uint32)(&Message[0][0]),
      (uint32)(&AtomPhaseSerial_TxBuffer[0][0]), 0,IfxDma_ChannelIncrementCircular_128,
      IfxDma_ChannelIncrementCircular_128, IfxDma_ChannelMoveSize_32bit);

  Dma_Init(&AtomPhaseSerial_DmaChannel[1], QUAD_SPI_BUFFER_SIZE >> 2, (uint32)(&Message[1][0]),
      (uint32)(&AtomPhaseSerial_TxBuffer[1][0]), 0,IfxDma_ChannelIncrementCircular_128, IfxDma_ChannelIncrementCircular_128,
      IfxDma_ChannelMoveSize_32bit);
  Dma_Init(&AtomPhaseSerial_DmaChannel[2], QUAD_SPI_BUFFER_SIZE >> 2, (uint32)(&Message[2][0]),
      (uint32)(&AtomPhaseSerial_TxBuffer[2][0]), QUAD_SPI_DMA_ISR,IfxDma_ChannelIncrementCircular_128,
      IfxDma_ChannelIncrementCircular_128, IfxDma_ChannelMoveSize_32bit);

}






/*Main function of the Three timers Phase shift PWM*/
void AtomPhaseSerial_Init(float32 baseFrequency,IfxGtm_Atom_ToutMap* masterPin, IfxGtm_Atom_ToutMapP* slavePins,
                          ATOMPHASESERIAL_INPUTBUFFER* Message)
{
  IfxGtm_Cmu_Clk ClckSrc= IfxGtm_Cmu_Clk_5;
  IfxGtm_Cmu_Clk SpiClk = IfxGtm_Cmu_Clk_4;
  float32 frequency;
  /* Enable GTM, it is necessary if the GTM is not initialized earlier */
  IfxGtm_enable(&MODULE_GTM);

  frequency = IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM);
  IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, SpiClk, frequency);

  /* Set the global clock frequency to the max */
  IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, frequency);
  /* Set the CMU CLK0 */
  IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, ClckSrc, baseFrequency);
  /* Enable the FXU clock and the SpiClock cmu clock */
  IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK5 | IFXGTM_CMU_CLKEN_CLK4);
  IfxGtm_Atom_Timer_Config TimerConfig;                                        /* Timer configuration              */
  IfxGtm_Atom_Timer_initConfig(&TimerConfig, &MODULE_GTM);                     /* Initialize timer configuration   */


  /*init pwm using the IfxGtm_Atom_Timer_Config of the Tom timer library*/
  TimerConfig.irqModeTrigger       = IfxGtm_IrqMode_level;              /* Enable the pulse of the Output signal as interrupt*/
  TimerConfig.base.frequency       = baseFrequency;                           /* Set timer frequency */
  TimerConfig.base.isrPriority     = MASTER_TIMER_ISR;                        /* Enable the master timer ISR */
  TimerConfig.base.isrProvider     = IfxSrc_Tos_cpu0;                         /* Isr on cpu 0 */
  TimerConfig.atom                  = masterPin->atom;                          /* Define the timer used */
  TimerConfig.timerChannel         = masterPin->channel;                      /* Define the channel used */
  TimerConfig.clock                = ClckSrc;

  IfxGtm_Atom_TimerSerial_init(&AtomPhaseSerial_Output.timer, &TimerConfig, ATOM_BITSHIFT , FALSE);   /* Initialize the TOM */
  IfxGtm_Atom_Agc_enableChannelUpdate(AtomPhaseSerial_Output.timer.agc,AtomPhaseSerial_Output.timer.triggerChannel,TRUE);

  /* Initialize the SpiClk Pwm */
  IfxGtmAtomSerialSetSpiClk(slavePins[MAX_ATOM_CHANNELS], SpiClk, baseFrequency);
  /* Here we stop the spi clock and we will update it inside the isr */
  IfxGtm_Atom_Timer_stop(&AtomPhaseSerial_Output.SpiClk);
  /* Initialize the slave mosi channels */
  IfxGtm_Atom_PwmHl_Config PwmHlConfig;

  IfxGtm_Atom_ToutMapP Ccx[] =
          {
              slavePins[0], /* PWM High-side 1 */
              slavePins[1], /* PWM High-side 2 */
              slavePins[2],  /* PWM High-side 3 is null since the third pwm phase is provide by the master timer*/
              slavePins[3]
          };
  IfxGtm_Atom_PwmHl_initConfig(&PwmHlConfig);
  PwmHlConfig.base.channelCount = MAX_ATOM_CHANNELS; /* Controlled channels are three */

  PwmHlConfig.base.outputMode = IfxPort_OutputMode_pushPull; /* Output mode is push pull */


  PwmHlConfig.base.outputDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1; /* Pad driver speed grade 1 */

  /* Set top PWM active state */
  PwmHlConfig.base.ccxActiveState = Ifx_ActiveState_low;


  PwmHlConfig.ccx   = Ccx;                        /* Assign the channels for High-side switches   */

  PwmHlConfig.timer = &AtomPhaseSerial_Output.timer;  /* Use as master timer the timer we initialized */
  PwmHlConfig.atom   = TimerConfig.atom;


  IfxGtm_AtomSerialChannelsInit(&AtomPhaseSerial_Output.pwm, &PwmHlConfig); /* Run the initialize of the three timers function */

  /* Initialize the Dma channels */
  AruPhaseSerial_DmaInit(Message);


  /* Set the shadow registers */
  IfxGtm_AtomSerialThreeTimersSetMode(&AtomPhaseSerial_Output.pwm, Ifx_Pwm_Mode_centerAligned);

  /* Update the input frequency */
  IfxGtm_Atom_Timer_updateInputFrequency(&AtomPhaseSerial_Output.timer);

  /* Initialize the cm0 registers with the bitshift */
  IfxGtm_Atom_Timer_disableUpdate(&AtomPhaseSerial_Output.timer);
  IfxGtmAtomSerialUpdatePeriod(&AtomPhaseSerial_Output.pwm);
  IfxGtm_Atom_Timer_applyUpdate(&AtomPhaseSerial_Output.timer);  /* Start every PWM signal at the same time */
  IfxGtm_Atom_Timer_stop(&AtomPhaseSerial_Output.timer);

}


void AtomPhaseSerial_StartQuadSpiTranscaction(uint32 size)
{
  AtomPhaseSerial_DataRemain = size << 1;

  if (AtomPhaseSerial_DataRemain > QUAD_SPI_BUFFER_SIZE)
  {
    AtomPhaseSerial_RingBufferSize += QUAD_SPI_BUFFER_SIZE;
  }
  else
  {
    AtomPhaseSerial_RingBufferSize += (uint8)AtomPhaseSerial_DataRemain;
    /* Transfer with Dma to all the fifos */
    for (uint8 i = 0; i < MOSI_CHANNELS; i++)
    {
      IfxDma_Dma_setChannelTransferCount(&AtomPhaseSerial_DmaChannel[i], size);
      IfxDma_startChannelTransaction(AtomPhaseSerial_DmaChannel[i].dma, AtomPhaseSerial_DmaChannel[i].channelId);
    }
  }
}

