/**********************************************************************************************************************
 * \file Serialinit.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <SerialInit.h>
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_Serial_TX 4
#define ISR_PRIORITY_Serial_RX 5
#define ISR_PRIORITY_Serial_ER 6
#define Serial_TX_BUFFER_SIZE 64
#define Serial_RX_BUFFER_SIZE 64
#define Serial_PRESCALER 1
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
Ifx_SizeT buffer_len = 128; /*define the buffer of read function*/
static uint8 uartRxbuffer[Serial_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
static uint8 uartTxBuffer[Serial_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 write_buffer[128];
uint8 read_buffer[128] = {''};
IfxAsclin_Asc uart_driver;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

uint8 Get_readBuf(Ifx_SizeT index)
{
    return read_buffer[index];
}

static inline void RstReadBuf(void)
{
    for(Ifx_SizeT i=0;i<sizeof(read_buffer);i++){
        read_buffer[i] = '\0';
    }
}

boolean charCmp(uint8 chr)
{
    if(read_buffer[0]== chr)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

boolean strcmp(uint8* message,uint8* read_string,Ifx_SizeT message_len)
{
    for(Ifx_SizeT i=0;i<message_len;i++)
    {
        if((read_string[i]=='\0') && (i<(message_len-1)))
        {
            return FALSE;
        }
        if (read_string[i]!=message[i])
        {
            return FALSE;
        }
    }
    return TRUE;
}

boolean SerialCmpString(uint8* message,Ifx_SizeT message_len)
{
    for(Ifx_SizeT i=0;i<message_len-1;i++)
       {
           if(read_buffer[i]!=message[i])
           {
               return FALSE;
           }
           else
           {
               /* Move to next index */
           }
       }
    return TRUE;
}
boolean SerialCmpCmd(uint8* message,Ifx_SizeT message_len)
{
    for(Ifx_SizeT i=0;i<message_len-1;i++)
    {
        if((read_buffer[i]=='\0') && (i<(message_len-1)))
        {
            return FALSE;
        }
        else if (read_buffer[i]!=message[i])
        {
            return FALSE;
        }
        else
        {

        }
    }
    if(read_buffer[message_len-1] == '\r')
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

boolean SerialCmpchar(uint8* message,Ifx_SizeT message_len,uint8 compareChar)
{
    for(Ifx_SizeT i=0;i<message_len-1;i++)
    {
        if((read_buffer[i]=='\0') && (i<(message_len-1)))
        {
            return FALSE;
        }
        else if (read_buffer[i]!=message[i])
        {
            return FALSE;
        }
        else
        {

        }
    }
    if((read_buffer[message_len-1] == compareChar) && (read_buffer[message_len]=='\r'))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

boolean SerialCmpNl(uint8* message,Ifx_SizeT message_len)
{
    for(Ifx_SizeT i=0;i<message_len-1;i++)
    {
        if((read_buffer[i]=='\0') && (i<(message_len-1)))
        {
            return FALSE;
        }
        else if (read_buffer[i]!=message[i])
        {
            return FALSE;
        }
        else
        {

        }
    }
    if((read_buffer[message_len-1] == '\r') && (read_buffer[message_len]=='\n'))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void SerialWritenl(uint8 *message,Ifx_SizeT length)
{
        for(Ifx_SizeT i=0;i<length;i++){
            write_buffer[i] = message[i];
        }
        write_buffer[length-1]= '\r';
        write_buffer[length]='\n';
        write_buffer[length+1] = '\0';
        Ifx_SizeT real_size = length+2;
     IfxAsclin_Asc_write(&uart_driver,write_buffer,&real_size,TIME_INFINITE);
}

void SerialWrite(uint8 *message,Ifx_SizeT length)
{
        for (Ifx_SizeT i=0;i<length;i++){
            write_buffer[i] = message[i];
        }
        write_buffer[length-1]='\r';
        write_buffer[length] = '\0';
        Ifx_SizeT real_size = length+1;
     IfxAsclin_Asc_write(&uart_driver,write_buffer,&real_size,TIME_INFINITE);
}

void SerialWriteWithChar(uint8 *message,Ifx_SizeT length,uint8 special_char)
{
        for (Ifx_SizeT i=0;i<length;i++)
        {
            write_buffer[i] = message[i];
        }
        write_buffer[length-1]= special_char;
        write_buffer[length]='\r';
        write_buffer[length+1] = '\0';
        Ifx_SizeT real_size = length+2;
     IfxAsclin_Asc_write(&uart_driver,write_buffer,&real_size,TIME_INFINITE);
}
void SerialWriteString(uint8* write_string,Ifx_SizeT length)
{
    IfxAsclin_Asc_write(&uart_driver,write_string,&length,TIME_INFINITE);
}

void SerialWriteChar(uint8 write_char)
{
    write_buffer[0] = write_char;
    Ifx_SizeT real_size = 1;
    IfxAsclin_Asc_write(&uart_driver,write_buffer,&real_size,TIME_INFINITE);
}

void SerialReadnl(Ifx_SizeT length)
{
    RstReadBuf();
    Ifx_SizeT read_len = length+2;
    /* Receive data */
    IfxAsclin_Asc_read(&uart_driver, read_buffer, &read_len, TIME_INFINITE);
}

void SerialReadwithChar(Ifx_SizeT length)
{
    RstReadBuf();
    Ifx_SizeT read_len = length+2;
    /* Receive data */
    IfxAsclin_Asc_read(&uart_driver, read_buffer, &read_len, TIME_INFINITE);
}

void SerialRead(Ifx_SizeT length)
{
    RstReadBuf();
    Ifx_SizeT read_len = length+1;
    /* Receive data */
    IfxAsclin_Asc_read(&uart_driver, read_buffer, &read_len, TIME_INFINITE);
}

void SerialReadChar(void)
{
    RstReadBuf();
    Ifx_SizeT read_len = 1;
    IfxAsclin_Asc_read(&uart_driver, read_buffer, &read_len, TIME_INFINITE);
}

void SerialReadString(Ifx_SizeT length)
{
    RstReadBuf();
    IfxAsclin_Asc_read(&uart_driver, read_buffer, &length, TIME_INFINITE);
}
/*UART ISR and read/write part */

IFX_INTERRUPT(SerialTxISR, 0 , ISR_PRIORITY_Serial_TX);

void SerialTxISR(void){
    IfxAsclin_Asc_isrTransmit(&uart_driver);
}

IFX_INTERRUPT(SerialRxISR, 0 , ISR_PRIORITY_Serial_RX);

void SerialRxISR(void){
    IfxAsclin_Asc_isrReceive(&uart_driver);
}

IFX_INTERRUPT(SerialErISR, 0 , ISR_PRIORITY_Serial_ER);

void SerialErISR(void){
    IfxAsclin_Asc_isrError(&uart_driver);
}

/*Uart initialize with RX and TX pins given by the user*/
void UartInit(IfxAsclin_Rx_In* RX_PIN,IfxAsclin_Tx_Out* TX_PIN,float32 baudrate){
    IfxAsclin_Asc_Config ascConf;
    IfxAsclin_Asc_initModuleConfig(&ascConf, TX_PIN->module);

    ascConf.baudrate.prescaler = Serial_PRESCALER;
    ascConf.baudrate.baudrate = baudrate;                                   /* Set the baud rate in bit/s       */

    /* ISR priorities and interrupt target */
    ascConf.interrupt.txPriority = ISR_PRIORITY_Serial_TX;/* Set the interrupt priority for TX events   */
    ascConf.interrupt.rxPriority = ISR_PRIORITY_Serial_RX;
    ascConf.interrupt.erPriority = ISR_PRIORITY_Serial_ER;
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;
    /* Pin configuration */
    const IfxAsclin_Asc_Pins pins =
    {
        NULL_PTR,       IfxPort_InputMode_pullUp,     /* CTS pin not used */
        RX_PIN,   IfxPort_InputMode_pullUp,     /* RX pin           */
        NULL_PTR,       IfxPort_OutputMode_pushPull,  /* RTS pin not used */
        TX_PIN,   IfxPort_OutputMode_pushPull,  /* TX pin           */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;
    /* FIFO buffers configuration */
    ascConf.txBuffer = &uartTxBuffer;                      /* Set the transmission buffer                          */
    ascConf.txBufferSize = Serial_TX_BUFFER_SIZE;
    ascConf.rxBuffer = &uartRxbuffer;
    ascConf.rxBufferSize = Serial_RX_BUFFER_SIZE;/* Set the transmission buffer size                     */


    /* Init ASCLIN module */
    IfxAsclin_Asc_initModule(&uart_driver, &ascConf);
}
