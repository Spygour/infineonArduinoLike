/**********************************************************************************************************************
 * \file phaseShiftAtomPwm.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "phaseShiftAtomPwm.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define MAX_ATOM_CHANNELS
#define APHASE_U_HS                &IfxGtm_ATOM1_4_TOUT14_P00_5_OUT /* Pin driven by the PWM, P00.11                  */
#define APHASE_V_HS                &IfxGtm_ATOM1_5_TOUT15_P00_6_OUT  /* Pin driven by the PWM, P33.0                   */
#define APHASE_W_HS                &IfxGtm_ATOM1_7_TOUT17_P00_8_OUT  /* Pin driven by the PWM, P33.2                   */


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Structure for three phase PWM output configuration and handling */
typedef struct
{
    IfxGtm_Atom_Timer    timer;                  /* Timer driver                                                      */
    IfxGtm_Atom_PwmHl    pwm;                    /* GTM TOM PWM driver object                                         */
    float32      pwmOnTimes[3];          /* PWM ON-time for 3 phases                                          */
    IfxGtm_Atom_PwmCcx update;
} APwm3PhaseOutput;

APwm3PhaseOutput g_Apwm3PhaseOutput;


/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/



/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

IFX_STATIC void IfxGtm_Atom_PwmCCX_updateOff(IfxGtm_Atom_PwmHl *driver, float32 *tOn)
{
    IFX_UNUSED_PARAMETER(tOn)
    uint8 channelIndex;
    Ifx_TimerValue period;
    period = driver->timer->base.period;

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
    {
        IfxGtm_Atom_Ch_setCompareShadow(driver->atom, driver->ccxTemp[channelIndex],
            2 /* 1 will keep the previous level*/, 2 + 2);
    }
}
void IfxGtm_Atom_PwmCCX_setOnTime(IfxGtm_Atom_PwmHl *driver, float32 *tOn)
{
    g_Apwm3PhaseOutput.update.set_mode(driver, tOn);
}




IFX_STATIC void IfxGtm_Atom_PwmCCX_updateCenterAligned(IfxGtm_Atom_PwmHl *driver, float32 *tOn)
{
        uint8   channelIndex;
        float32 period;

        period =(float) driver->timer->base.period;

        for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
        {

            float32 x;
            float32 cm0;
            float32 cm1;
            x = tOn[channelIndex];
            if ((x+period/2)>=period){
                cm1 = x;
                cm0 = x+(period/2)-period+2;
                IfxGtm_Atom_Ch_setCompareShadow(driver->atom, driver->ccxTemp[channelIndex], cm0,cm1);
            }
            else if(x==0){
                x=x+2;
                cm1 = x; // CM1
                cm0 = x+(period/2); // CM0
                IfxGtm_Atom_Ch_setCompareShadow(driver->atom, driver->ccxTemp[channelIndex], cm0,cm1);
            }
            else{
                          /* x% duty cycle */
                cm1 = x; // CM1
                cm0 = x+(period/2); // CM0
                IfxGtm_Atom_Ch_setCompareShadow(driver->atom, driver->ccxTemp[channelIndex], cm0,cm1);
            }

        /*To add two more modes*/
         }

}




IFX_STATIC IFX_CONST IfxGtm_Atom_PwmCcx IfxGtm_Atom_Pwmccx_modes[2] = {
    {Ifx_Pwm_Mode_centerAligned,         FALSE, &IfxGtm_Atom_PwmCCX_updateCenterAligned},
    {Ifx_Pwm_Mode_off,                   FALSE, &IfxGtm_Atom_PwmCCX_updateOff }
};


boolean IfxGtm_Atom_Pwmccx_setMode(IfxGtm_Atom_PwmHl *driver, Ifx_Pwm_Mode mode)
{
    boolean                result = TRUE;
     IfxGtm_Atom_PwmHl_Base *base   = &driver->base;

     if (base->mode != mode)
     {
         if (mode > Ifx_Pwm_Mode_off)
         {
             mode   = Ifx_Pwm_Mode_off;
             result = FALSE;
         }

         IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, mode == IfxGtm_Tom_Pwmccx_modes[mode].mode);

         base->mode             = mode;
         g_Apwm3PhaseOutput.update         = IfxGtm_Atom_Pwmccx_modes[0];

             driver->ccxTemp   = driver->ccx;

           /* Workaround to enable the signal inversion required for center aligned inverted
              * and right aligned modes */
             /** \note that changing signal level may produce short circuit at the power stage,
              * in which case the inverter must be disable during this action. */

             /* Ifx_Pwm_Mode_centerAligned and Ifx_Pwm_Mode_LeftAligned use inverted=FALSE */
             /* Ifx_Pwm_Mode_centerAlignedInverted and Ifx_Pwm_Mode_RightAligned use inverted=TRUE */
             uint32 channelIndex;

             for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
             {
                 IfxGtm_Atom_Ch channel;

                 channel = driver->ccx[channelIndex];
                 IfxGtm_Atom_Ch_setSignalLevel(driver->atom, channel, base->ccxActiveState);

             }

     }

     return result;
}

boolean IfxGtm_Atom_Pwmccx_init(IfxGtm_Atom_PwmHl *driver,IfxGtm_Atom_PwmHl_Config *config)
{
        boolean  result       = TRUE;
       uint16             channelMask;
       uint16             channelsMask = 0;
       uint32             channelIndex;

       IfxGtm_Atom_Timer *timer = config->timer;

       driver->base.mode             = Ifx_Pwm_Mode_init;
       driver->timer                 = timer;
       driver->base.setMode          = 0;
       driver->base.inverted         = FALSE;
       driver->base.ccxActiveState   = config->base.ccxActiveState;
       driver->base.coutxActiveState = config->base.coutxActiveState;
       driver->base.channelCount     = config->base.channelCount;

       IfxGtm_Atom_PwmHl_setDeadtime(driver, config->base.deadtime);
       IfxGtm_Atom_PwmHl_setMinPulse(driver, config->base.minPulse);

       driver->atom = &(timer->gtm->ATOM[config->atom]);
       /* Only one AGC  */
       driver->agc  = (Ifx_GTM_ATOM_AGC *)&driver->atom->AGC.GLB_CTRL;

       IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, config->base.channelCount <= IFXGTM_ATOM_PWMHL_MAX_NUM_CHANNELS);

       IfxGtm_Cmu_Clk clock = IfxGtm_Atom_Ch_getClockSource(timer->atom, timer->timerChannel);


        for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
        {
            IfxGtm_Atom_Ch channel;
            /* CCX */
            channel                   = config->ccx[channelIndex]->channel;
            driver->ccx[channelIndex] = channel;
            channelMask               = 1 << channel;
            channelsMask             |= channelMask;

            /* Initialize the timer part */
            IfxGtm_Atom_Ch_configurePwmMode(driver->atom, channel, clock,Ifx_ActiveState_high, IfxGtm_Atom_Ch_ResetEvent_onTrigger, IfxGtm_Atom_Ch_OutputTrigger_forward);

            /* Initialize the port */
            if (config->initPins == TRUE)
            {
                IfxGtm_PinMap_setAtomTout(config->ccx[channelIndex],
                    config->base.outputMode, config->base.outputDriver);
            }

        }
        IfxGtm_Atom_Agc_enableChannelsOutput(driver->agc, channelsMask, 0, TRUE);
            IfxGtm_Atom_Agc_enableChannels(driver->agc, channelsMask, 0, TRUE);

            IfxGtm_Atom_PwmHl_setMode(driver, Ifx_Pwm_Mode_off);

            float32 tOn[IFXGTM_ATOM_PWMHL_MAX_NUM_CHANNELS] = {0};
            IfxGtm_Atom_PwmCCX_updateOff(driver, tOn); /* tOn do not need defined values */

            /* Transfer the shadow registers */
            IfxGtm_Atom_Agc_setChannelsForceUpdate(driver->agc, channelsMask, 0, 0, 0);
            IfxGtm_Atom_Agc_trigger(driver->agc);
            IfxGtm_Atom_Agc_setChannelsForceUpdate(driver->agc, 0, channelsMask, 0, 0);

            /* Enable timer to update the channels */

            for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
            {
                IfxGtm_Atom_Timer_addToChannelMask(timer, driver->ccx[channelIndex]);
            }

            return result;
}

void InitChannelsAPwm(float PWM_FREQ,IfxGtm_Atom atomMaster,IfxGtm_Atom_Ch atomMasterChannel,float32 phase_shift){
/* Enable the GTM Module */
     IfxGtm_enable(&MODULE_GTM);
     /* Set the GTM global clock frequency in Hz */
     IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM));
     /* Set the GTM configurable clock frequency in Hz */
     IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, IfxGtm_Cmu_getGclkFrequency(&MODULE_GTM));
     /* Enable the FXU clock                         */
     IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);

     IfxGtm_Atom_Timer_Config timerConfig;                                         /* Timer configuration              */
     {
         IfxGtm_Atom_Timer_initConfig(&timerConfig, &MODULE_GTM);                  /* Initialize default parameters    */

         timerConfig.base.frequency = PWM_FREQ;                                /* Set timer frequency              */
         timerConfig.clock= IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;                       /* Define the CMU clock used        */
         timerConfig.atom = atomMaster;                                        /* Define the timer used            */
         timerConfig.timerChannel = atomMasterChannel;                      /* Define the channel used          */
     }
         IfxGtm_Atom_Timer_init(&g_Apwm3PhaseOutput.timer, &timerConfig);           /* Initialize the TOM               */

         IfxGtm_Atom_PwmHl_Config pwmHlConfig;

         IfxGtm_Atom_ToutMapP ccx[] =
                 {
                     APHASE_U_HS, /* PWM High-side 1 */
                     APHASE_V_HS, /* PWM High-side 2 */
                     APHASE_W_HS  /* PWM High-side 3 */
                 };
         IfxGtm_Atom_PwmHl_initConfig(&pwmHlConfig);
         pwmHlConfig.base.channelCount = sizeof(ccx) / sizeof(IfxGtm_Atom_ToutMapP);

         pwmHlConfig.base.outputMode = IfxPort_OutputMode_pushPull;


         pwmHlConfig.base.outputDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;

         /* Set top PWM active state */
         pwmHlConfig.base.ccxActiveState = Ifx_ActiveState_high;


         pwmHlConfig.ccx   = ccx;                        /* Assign the channels for High-side switches   */

         pwmHlConfig.timer = &g_Apwm3PhaseOutput.timer;
         pwmHlConfig.atom   = timerConfig.atom;

         IfxGtm_Atom_Pwmccx_init(&g_Apwm3PhaseOutput.pwm, &pwmHlConfig);

         IfxGtm_Atom_Pwmccx_setMode(&g_Apwm3PhaseOutput.pwm, Ifx_Pwm_Mode_centerAligned);
         /* Update the input frequency */
         IfxGtm_Atom_Timer_updateInputFrequency(&g_Apwm3PhaseOutput.timer);
         IfxGtm_Atom_Timer_run(&g_Apwm3PhaseOutput.timer);
         /* Calculate initial values of PWM duty cycles */
         g_Apwm3PhaseOutput.pwmOnTimes[0] = g_Apwm3PhaseOutput.pwm.timer->base.period * 0.01;
         g_Apwm3PhaseOutput.pwmOnTimes[1] = g_Apwm3PhaseOutput.pwm.timer->base.period * phase_shift;
         g_Apwm3PhaseOutput.pwmOnTimes[2] = g_Apwm3PhaseOutput.pwm.timer->base.period * 2*phase_shift;
         /* Update PWM duty cycles */
         IfxGtm_Atom_Timer_disableUpdate(&g_Apwm3PhaseOutput.timer);
         IfxGtm_Atom_PwmCCX_setOnTime(&g_Apwm3PhaseOutput.pwm, g_Apwm3PhaseOutput.pwmOnTimes);
         IfxGtm_Atom_Timer_applyUpdate(&g_Apwm3PhaseOutput.timer);
}
