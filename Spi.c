/**********************************************************************************************************************
 * \file Spi.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Spi.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_SPIMASTER_TX 43
#define ISR_PRIORITY_SPIMASTER_RX 44
#define ISR_PRIORITY_SPIMASTER_ER 45
#define ISR_PRIORITY_SPISLAVE_TX 46
#define ISR_PRIORITY_SPISLAVE_RX 47
#define ISR_PRIORITY_SPISLAVE_ER 48
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxQspi_SpiMaster *SpiMaster1Ptr = NULL_PTR;
IfxQspi_SpiSlave  *SpiSlave1Ptr = NULL_PTR;


uint8 SpiTxBuffer[20];
uint8 SpiRxBuffer[20];
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
 IFX_INTERRUPT(SpimasterTxISR, 0, ISR_PRIORITY_SPIMASTER_TX);                  /* SPI Master ISR for transmit data         */
 IFX_INTERRUPT(SpimasterRxISR, 0, ISR_PRIORITY_SPIMASTER_RX);                  /* SPI Master ISR for receive data          */
 IFX_INTERRUPT(SpimasterErISR, 0, ISR_PRIORITY_SPIMASTER_ER);                 /* SPI Master ISR for error                 */
 IFX_INTERRUPT(SpiSlaveTxISR, 0, ISR_PRIORITY_SPISLAVE_TX);                  /* SPI Master ISR for transmit data         */
 IFX_INTERRUPT(SpiSlaveRxISR, 0, ISR_PRIORITY_SPISLAVE_RX);                  /* SPI Master ISR for receive data          */
 IFX_INTERRUPT(SpiSlaverErISR, 0, ISR_PRIORITY_SPISLAVE_ER);                 /* SPI Master ISR for error                 */

 void SpimasterTxISR(void){
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrTransmit(SpiMaster1Ptr);
 }

 void SpimasterRxISR(void ){
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrReceive(SpiMaster1Ptr);
 }

 void SpimasterErISR(void){
     IfxCpu_enableInterrupts();
     IfxQspi_SpiMaster_isrError(SpiMaster1Ptr);
 }

 void Spi_Init(IfxQspi_SpiMaster* SpiMaster, SpiMasterPins_t* SpiMasterPins)
 {
   SpiMaster1Ptr = SpiMaster;
   IfxQspi_SpiMaster_Config spiMasterConfig;                           /* Define a Master configuration            */

   IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, SpiMasterPins->SpiMosi->module); /* Initialize it with default values        */

   spiMasterConfig.base.mode = SpiIf_Mode_master;                      /* Configure the mode                       */

   /* Select the port pins for communication */
   const IfxQspi_SpiMaster_Pins SpiMasterPinsCfg = {
       SpiMasterPins->SpiClk, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
       SpiMasterPins->SpiMosi, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
       SpiMasterPins->SpiMiso, IfxPort_InputMode_pullDown,           /* MasterReceiveSlaveTransmit pin (MISO)    */
       IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
   };
   /* Select the port pins for communication */
   spiMasterConfig.pins = &SpiMasterPinsCfg;                            /* Assign the Master's port pins            */

   /* Set the ISR priorities and the service provider */
   spiMasterConfig.base.txPriority = ISR_PRIORITY_SPIMASTER_TX;
   spiMasterConfig.base.rxPriority = ISR_PRIORITY_SPIMASTER_RX;
   spiMasterConfig.base.erPriority = ISR_PRIORITY_SPIMASTER_ER;
   spiMasterConfig.base.isrProvider = IfxSrc_Tos_cpu0;
   /* Initialize the QSPI Master module */
   IfxQspi_SpiMaster_initModule(SpiMaster, &spiMasterConfig);
 }

 void Spi_ChannelInit(IfxQspi_SpiMaster* SpiMaster, IfxQspi_SpiMaster_Channel* SpiChannel, SpiChannelConfig* ChannelConfig)
 {
   IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;             /* Define a Master Channel configuration    */

   /* Initialize the configuration with default values */
   IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, SpiMaster);

   const IfxQspi_SpiMaster_Output SpiSlaveSelect = {                 /* QSPI1 Master selects the QSPI3 Slave     */
       ChannelConfig->ChannelOutput, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
       IfxPort_PadDriver_cmosAutomotiveSpeed1                          /* Pad driver mode                          */
   };
   spiMasterChannelConfig.sls.output = SpiSlaveSelect;

   spiMasterChannelConfig.base.baudrate = ChannelConfig->Baudrate;    /* Set SCLK frequency to 10 MHz              */
   spiMasterChannelConfig.base.mode.dataWidth = 8;        /* Set the transfer data width to 8 bits    */
   spiMasterChannelConfig.base.mode.clockPolarity = ChannelConfig->ClockPolarity;
   spiMasterChannelConfig.base.mode.shiftClock = ChannelConfig->ShiftClock;
   spiMasterChannelConfig.base.mode.dataHeading = ChannelConfig->DataHeading;
   spiMasterChannelConfig.base.mode.parityCheck = 0;
   spiMasterChannelConfig.base.mode.autoCS =0;

   /* Select the port pin for the Chip Select signal */


   /* Initialize the QSPI Master channel */
   IfxQspi_SpiMaster_initChannel(SpiChannel, &spiMasterChannelConfig);
 }

 void Spi_WriteRegister(IfxQspi_SpiMaster_Channel* SpiChannel, uint8 Reg)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );
   SpiTxBuffer[0] = Reg;
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], 1);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy);

 }

 void Spi_ReadRegister(IfxQspi_SpiMaster_Channel* SpiChannel, uint8 Reg, uint8* regVal, uint8 size)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );
   SpiTxBuffer[0] =  Reg;
   for(uint8 i = 0; i < size; i++)
   {
     SpiTxBuffer[i+1] = 0xFF;
   }
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], size+1);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );

   for(uint8 i=0; i<size;i++)
   {
     regVal[i] = SpiRxBuffer[i+1];
   }
 }

 void Spi_WriteBytes(IfxQspi_SpiMaster_Channel* SpiChannel, uint8* Src, uint8 size)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );
   for(uint8 i = 0; i < size; i++)
   {
     SpiTxBuffer[i] = Src[i];
   }
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], size);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );
 }

 void Spi_ReadBytes(IfxQspi_SpiMaster_Channel* SpiChannel,uint8* Src, uint8 SrcSize, uint8* Dest, uint8 DestSize)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );
   for(uint8 i=0;i<SrcSize;i++)
   {
     SpiTxBuffer[i] = Src[i];
   }
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], DestSize+1);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == SpiIf_Status_busy );

   for(uint8 i = 0; i < DestSize; i++)
   {
     Dest[i] = SpiRxBuffer[i+1];
   }

 }


 /*************************************************************************/
 /************************** SPI Slave Part *******************************/
 /*************************************************************************/

 void SpiSlaveTxISR(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiSlave_isrTransmit(SpiSlave1Ptr);
 }

 void SpiSlaveRxISR(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiSlave_isrReceive(SpiSlave1Ptr);
 }

 void SpiSlaveErISR(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiSlave_isrError(SpiSlave1Ptr);
 }

void Spi_SlaveInit(IfxQspi_SpiSlave* SpiSlave,SpiSlavePins_t* SpiSlavePins, SpiChannelConfig* ChannelConfig)
{
  SpiSlave1Ptr = SpiSlave;
  // create module config
  IfxQspi_SpiSlave_Config spiSlaveConfig;
  IfxQspi_SpiSlave_initModuleConfig(&spiSlaveConfig, SpiSlavePins->SpiChipSelect->module);

  // set the maximum baudrate
  spiSlaveConfig.base.maximumBaudrate  = ChannelConfig->Baudrate;
  spiSlaveConfig.protocol.clockPolarity = ChannelConfig->ClockPolarity;
  spiSlaveConfig.protocol.dataHeading = ChannelConfig->DataHeading;

  // pin configuration
  const IfxQspi_SpiSlave_Pins slavePins = {
      SpiSlavePins->SpiClkIn, IfxPort_InputMode_pullDown,   // SCLK Pin
      SpiSlavePins->SpiMosi, IfxPort_InputMode_pullDown,   // MTSR Pin
      SpiSlavePins->SpiMiso, IfxPort_OutputMode_pushPull,  // MRST Pin
      SpiSlavePins->SpiChipSelect, IfxPort_InputMode_pullDown,   // SLSI Pin
      IfxPort_PadDriver_cmosAutomotiveSpeed2 // pad driver mode
  };
  spiSlaveConfig.pins = &slavePins;

  // ISR priorities and interrupt target
  spiSlaveConfig.base.txPriority       = ISR_PRIORITY_SPISLAVE_TX;
  spiSlaveConfig.base.rxPriority       = ISR_PRIORITY_SPISLAVE_RX;
  spiSlaveConfig.base.erPriority       = ISR_PRIORITY_SPISLAVE_ER;
  spiSlaveConfig.base.isrProvider      = IfxSrc_Tos_cpu0;

  //spiSlaveConfig.qspi->GLOBALCON.B.STIP = 1;
  // initialize module
  IfxQspi_SpiSlave_initModule(SpiSlave, &spiSlaveConfig);

}

void Spi_SlaveExchange(IfxQspi_SpiSlave* SpiSlave, uint8* SpiSlaveTx, uint8* SpiSlaveRx, uint8 size)
{
  for (uint8 i = 0; i < size; i++)
  {
    SpiTxBuffer[i] = SpiSlaveTx[i];
  }

  while( IfxQspi_SpiSlave_getStatus(SpiSlave) == SpiIf_Status_busy );

  IfxQspi_SpiSlave_exchange(SpiSlave, &SpiTxBuffer[0], &SpiRxBuffer[0], size);

  while( IfxQspi_SpiSlave_getStatus(SpiSlave) == SpiIf_Status_busy );

  for (uint8 i = 0; i< size; i++)
  {
    SpiSlaveRx[i] = SpiRxBuffer[i];
  }

}
