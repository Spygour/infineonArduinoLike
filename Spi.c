/**********************************************************************************************************************
 * \file Spi.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Spi.h"
#include "utils/std_int.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_SPISLAVE_TX 55
#define ISR_PRIORITY_SPISLAVE_RX 56
#define ISR_PRIORITY_SPISLAVE_ER 57
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/


IfxQspi_SpiSlave  *SpiSlave1Ptr = NULL_PTR;


static uint8 SpiTxBuffer[256];
static uint8 SpiRxBuffer[256];


/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/


 IFX_INTERRUPT(SpiSlaveTxISR, 0, ISR_PRIORITY_SPISLAVE_TX);                  /* SPI Master ISR for transmit data         */
 IFX_INTERRUPT(SpiSlaveRxISR, 0, ISR_PRIORITY_SPISLAVE_RX);                  /* SPI Master ISR for receive data          */
 IFX_INTERRUPT(SpiSlaverErISR, 0, ISR_PRIORITY_SPISLAVE_ER);                 /* SPI Master ISR for error                 */



 /** \brief Initializes the Spi Module
  * \param Spi_ChannelInit
  * \return void
  */
 void Spi_Init(SpiMasterPins_t* SpiMasterPins, SpiMasterCfg_t* MasterCfg)
 {
   IfxQspi_SpiMaster_Config spiMasterConfig;                           /* Define a Master configuration            */

   IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, SpiMasterPins->SpiMosi->module); /* Initialize it with default values        */

   spiMasterConfig.mode = IfxQspi_Mode_master;                      /* Configure the mode                       */

   /* Select the port pins for communication */
   const IfxQspi_SpiMaster_Pins SpiMasterPinsCfg = {
       SpiMasterPins->SpiClk, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
       SpiMasterPins->SpiMosi, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
       SpiMasterPins->SpiMiso, IfxPort_InputMode_pullDown,           /* MasterReceiveSlaveTransmit pin (MISO)    */
       IfxPort_PadDriver_cmosAutomotiveSpeed2                          /* Pad driver mode                          */
   };
   /* Select the port pins for communication */
   spiMasterConfig.pins = &SpiMasterPinsCfg;                            /* Assign the Master's port pins            */

   /* Set the ISR priorities and the service provider */
   spiMasterConfig.txPriority = MasterCfg->TxIsr;
   spiMasterConfig.rxPriority = MasterCfg->RxIsr;
   spiMasterConfig.erPriority = MasterCfg->ErIsr;
   spiMasterConfig.isrProvider = IfxSrc_Tos_cpu0;
   /* Initialize the QSPI Master module */
   IfxQspi_SpiMaster_initModule(MasterCfg->SpiMasterPtr, &spiMasterConfig);

   MasterCfg->IsActive = TRUE;
 }



 /** \brief Initialize an Spi Channel
  * \param Spi_ChannelInit
  * \return void
  */
 void Spi_ChannelInit(SpiMasterCfg_t* SpiMasterCfg, SpiChannel_t* SpiChannel, SpiChannelConfig* ChannelConfig)
 {
   IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;             /* Define a Master Channel configuration    */

   /* Initialize the configuration with default values */
   IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, SpiMasterCfg->SpiMasterPtr);

   const IfxQspi_SpiMaster_Output SpiSlaveSelect = {                 /* QSPI1 Master selects the QSPI3 Slave     */
       ChannelConfig->ChannelOutput, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
       IfxPort_PadDriver_cmosAutomotiveSpeed1                          /* Pad driver mode                          */
   };
   spiMasterChannelConfig.sls.output = SpiSlaveSelect;

   spiMasterChannelConfig.ch.baudrate = ChannelConfig->Baudrate;    /* Set SCLK frequency to 10 MHz              */
   spiMasterChannelConfig.ch.mode.dataWidth = ChannelConfig->DataWidth;        /* Set the transfer data width to 8 bits    */
   spiMasterChannelConfig.ch.mode.clockPolarity = ChannelConfig->ClockPolarity;
   spiMasterChannelConfig.ch.mode.shiftClock = ChannelConfig->ShiftClock;
   spiMasterChannelConfig.ch.mode.dataHeading = ChannelConfig->DataHeading;
   spiMasterChannelConfig.ch.mode.parityCheck = 0;
   spiMasterChannelConfig.ch.mode.autoCS = 0;

   /* Select the port pin for the Chip Select signal */


   /* Initialize the QSPI Master channel */
   IfxQspi_SpiMaster_initChannel(SpiChannel, &spiMasterChannelConfig);
 }



 /** \brief Writes one byte throug Spi
  * \param Spi_WriteRegister
  * \return void
  */
 void Spi_WriteRegister(SpiChannel_t* SpiChannel, uint8 Reg)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   SpiTxBuffer[0] = Reg;
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], 1);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy);

 }



 /** \brief Writes to one register
  * \param Spi_WriteRegisterVal
  * \return void
  */
 void Spi_WriteRegisterVal(SpiChannel_t* SpiChannel, uint8 Reg, uint8 Val)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   SpiTxBuffer[0] = Reg;
   SpiTxBuffer[1] = Val;
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], 2);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy);

 }



 /** \brief Reads one or more than one registers
  * \param Spi_ReadRegister
  * \return void
  */
 void Spi_ReadRegister(SpiChannel_t* SpiChannel, uint8 Reg, uint8* regVal, uint16 size)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   SpiTxBuffer[0] =  Reg;
   for(uint16 i = 0; i < size; i++)
   {
     SpiTxBuffer[i+1] = 0xFF;
   }
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], size+1);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   memcpy(regVal, &SpiRxBuffer[1], size);
 }



 /** \brief This writes bytes from a array to tx buffer and then writes through spi
  * \param Spi_WriteBytes read function
  * \return void
  */
 void Spi_WriteBytes(SpiChannel_t* SpiChannel, uint8* Src, uint16 size)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   memcpy(Src, SpiTxBuffer, size);

       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], NULL_PTR, size);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
 }



 /** \brief This reads bytes, stores data to the RxBuffer and copy the data to an pointer
  * \param Spi_ReadBytes
  * \return void
  */
 void Spi_ReadBytes(SpiChannel_t* SpiChannel,uint8* Src, uint16 SrcSize, uint8* Dest, uint16 DestSize)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   for(uint16 i=0;i<SrcSize;i++)
   {
     SpiTxBuffer[i] = Src[i];
   }
   for(uint16 i = SrcSize; i < (DestSize + 1); i++)
   {
     SpiTxBuffer[i] = 0xFF;
   }
       // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0], DestSize + 1);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );

   for(uint16 i = 0; i < DestSize; i++)
   {
     Dest[i] = SpiRxBuffer[i+1];
   }
 }



 /** \brief This Writes the data the is in the SpiTxBuffer
  * \param Spi_WriteBuffer
  * \return void
  */
 void Spi_WriteBuffer(SpiChannel_t* SpiChannel, uint16 size)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], NULL_PTR,size);

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
 }



 /** \brief This reads and stores data to the RxBuffer
  * \param Spi_ReadBuffer read function
  * \return void
  */
 void Spi_ReadBuffer(SpiChannel_t* SpiChannel,uint8* Src, uint16 SrcSize, uint16 size)
 {
   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );

   for(uint16 i=0;i<SrcSize;i++)
   {
     SpiTxBuffer[i] = Src[i];
   }
   for(uint16 i=SrcSize; i <= size; i++)
   {
     SpiTxBuffer[i] = 0xFF;
   }

   // receive new stream
   IfxQspi_SpiMaster_exchange(SpiChannel, &SpiTxBuffer[0], &SpiRxBuffer[0],(size+1));

   while( IfxQspi_SpiMaster_getStatus(SpiChannel) == IfxQspi_Status_busy );
 }



 /** \brief This returns the address of the TxBuffer
  * \param Spi_ReturnSpiTxBufferAddr read function
  * \return uint32
  */
 uint32 Spi_ReturnSpiTxBufferAddr(uint16 index)
 {
   return (uint32)(&SpiTxBuffer[index]);
 }



 /** \brief This returns the address of the RxBuffer
  * \param Spi_ReturnRxBufferAddr read function
  * \return uint32
  */
 uint32 Spi_ReturnSpiRxBufferAddr(uint16 index)
 {
   return (uint32)(&SpiRxBuffer[index]);
 }



 /** \brief This sets a value in specific index of the TxBuffer
   * \param Spi_SetTxBufferIndex
   * \return uint32
   */
void Spi_SetTxBufferIndex(uint8 val, uint8 index)
{
  SpiTxBuffer[index] = val;
}

/**************************************************************************/
/****************************SPI DMA PART *********************************/
/**************************************************************************/
/** \brief Initializes the Spi Module
 * \param Spi_ChannelInit
 * \return void
 */
void Spi_DmaInit(SpiMasterPins_t* SpiMasterPins, SpiMasterDmaCfg_t* MasterCfg)
{
  IfxQspi_SpiMaster_Config spiMasterConfig;                           /* Define a Master configuration            */

  IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, SpiMasterPins->SpiMosi->module); /* Initialize it with default values        */

  spiMasterConfig.mode = IfxQspi_Mode_master;                      /* Configure the mode                       */

  /* Select the port pins for communication */
  const IfxQspi_SpiMaster_Pins SpiMasterPinsCfg = {
      SpiMasterPins->SpiClk, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
      SpiMasterPins->SpiMosi, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
      SpiMasterPins->SpiMiso, IfxPort_InputMode_pullDown,           /* MasterReceiveSlaveTransmit pin (MISO)    */
      IfxPort_PadDriver_cmosAutomotiveSpeed2                          /* Pad driver mode                          */
  };
  /* Select the port pins for communication */
  spiMasterConfig.pins = &SpiMasterPinsCfg;                            /* Assign the Master's port pins            */

  /* Set the ISR priorities and the service provider */
  spiMasterConfig.txPriority = 0u;
  spiMasterConfig.rxPriority = MasterCfg->RxIsr;
  spiMasterConfig.erPriority = MasterCfg->ErIsr;
  spiMasterConfig.dma.rxDmaChannelId = MasterCfg->DmaCfgPtr->rxDmaChannelId;
  spiMasterConfig.dma.txDmaChannelId = MasterCfg->DmaCfgPtr->txDmaChannelId;
  spiMasterConfig.dma.useDma = TRUE;
  spiMasterConfig.isrProvider = IfxSrc_Tos_cpu0;
  /* Initialize the QSPI Master module */
  IfxQspi_SpiMaster_initModuleAsync(MasterCfg->SpiMasterPtr, &spiMasterConfig);

  MasterCfg->IsActive = TRUE;
}


/** \brief Initialize an Spi Channel
 * \param Spi_ChannelInit
 * \return void
 */
void Spi_DmaChannelInit(SpiMasterDmaCfg_t* SpiMasterCfg, SpiChannel_t* SpiChannel, SpiChannelConfig* ChannelConfig)
{
  IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;             /* Define a Master Channel configuration    */

  /* Initialize the configuration with default values */
  IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, SpiMasterCfg->SpiMasterPtr);

  const IfxQspi_SpiMaster_Output SpiSlaveSelect = {                 /* QSPI1 Master selects the QSPI3 Slave     */
      ChannelConfig->ChannelOutput, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
      IfxPort_PadDriver_cmosAutomotiveSpeed1                          /* Pad driver mode                          */
  };
  spiMasterChannelConfig.sls.output = SpiSlaveSelect;

  spiMasterChannelConfig.ch.baudrate = ChannelConfig->Baudrate;    /* Set SCLK frequency to 10 MHz              */
  spiMasterChannelConfig.ch.mode.dataWidth = ChannelConfig->DataWidth;        /* Set the transfer data width to 8 bits    */
  spiMasterChannelConfig.ch.mode.clockPolarity = ChannelConfig->ClockPolarity;
  spiMasterChannelConfig.ch.mode.shiftClock = ChannelConfig->ShiftClock;
  spiMasterChannelConfig.ch.mode.dataHeading = ChannelConfig->DataHeading;
  spiMasterChannelConfig.ch.mode.parityCheck = 0;
  spiMasterChannelConfig.ch.mode.autoCS = 1;
  spiMasterChannelConfig.dma->useDma = TRUE;
  spiMasterChannelConfig.dma->txDmaChannelId = SpiMasterCfg->DmaCfgPtr->txDmaChannelId;
  spiMasterChannelConfig.dma->rxDmaChannelId = SpiMasterCfg->DmaCfgPtr->rxDmaChannelId;
  spiMasterChannelConfig.channelBasedCs = IfxQspi_SpiMaster_ChannelBasedCs_enabled;
  spiMasterChannelConfig.mode = IfxQspi_SpiMaster_Mode_short;
  spiMasterChannelConfig.ch.mode.csInactiveDelay = 10;
  spiMasterChannelConfig.ch.mode.csLeadDelay = 4;
  spiMasterChannelConfig.ch.mode.csTrailDelay = 5;

  spiMasterChannelConfig.dma->txDmaChannel.channel = &MODULE_DMA.CH[SpiMasterCfg->DmaCfgPtr->txDmaChannelId];
  spiMasterChannelConfig.dma->txDmaChannel.dma = &MODULE_DMA;
  spiMasterChannelConfig.dma->txDmaChannel.channelId = SpiMasterCfg->DmaCfgPtr->txDmaChannelId;

  spiMasterChannelConfig.dma->rxDmaChannel.channel = &MODULE_DMA.CH[SpiMasterCfg->DmaCfgPtr->rxDmaChannelId];
  spiMasterChannelConfig.dma->rxDmaChannel.dma = &MODULE_DMA;
  spiMasterChannelConfig.dma->rxDmaChannel.channelId = SpiMasterCfg->DmaCfgPtr->rxDmaChannelId;

  /* Select the port pin for the Chip Select signal */


  /* Initialize the QSPI Master channel */
  IfxQspi_SpiMaster_initChannel(SpiChannel, &spiMasterChannelConfig);

}

void SpiAsync(IfxQspi_SpiMaster_Channel *chHandle, const void *src, void *dest, Ifx_SizeT count)
{
    IfxQspi_SpiMaster_DmaExchange(chHandle, src,
                               dest, count, IfxDma_ChannelIncrementCircular_128);
}

/* Example of usage the Spi async
 * ***Note this needs extra update on the IfxQspi_SpiMaster file, Please contact me for the extra functions */

//static IfxQspi_SpiMaster Master;
//static DmaConfig_t SpiDmaCfg = {
//        IfxDma_ChannelId_3,
//        IfxDma_ChannelId_4,
//        TRUE
//};
//static SpiMasterDmaCfg_t SpiMaster =  {
//        &Master,
//        &SpiDmaCfg,
//        DMA_ISR_TX,
//        DMA_ISR_RX,
//        DMA_ISR_ERR
//};
//
//static SpiMasterPins_t SpiPins = {
//    &IfxQspi1_SCLK_P10_2_OUT,
//    &IfxQspi1_MTSR_P10_3_OUT,
//    &IfxQspi1_MRSTA_P10_1_IN
//};
//
//static SpiChannelConfig SpiChannelCfg = {
//        &IfxQspi1_SLSO3_P11_10_OUT,
//        5000000 ,
//        0,
//        TRUE,
//        32,
//        TRUE
//    };
//
//static SpiChannel_t SpiChannel;
//
//
//uint32 BytesRemain;
//volatile uint32 BytesSent = 0;
//volatile boolean SpiEnd = FALSE;
//
//IFX_INTERRUPT(Dma_IsrRx, 0 , DMA_ISR_RX);
//void Dma_IsrRx(void)
//{
//    IfxCpu_enableInterrupts();
//    IfxQspi_SpiMaster_isrDmaReceiveAsync(SpiMaster.SpiMasterPtr);
//}
//
//IFX_INTERRUPT(Dma_IsrErr, 0 , DMA_ISR_ERR);
//void Dma_IsrErr(void)
//{
//    IfxCpu_enableInterrupts();
//    IfxQspi_SpiMaster_isrError(SpiMaster.SpiMasterPtr);
//}
 /*************************************************************************/
 /************************** SPI Slave Part *******************************/
 /*************************************************************************/

 void SpiSlaveTxISR(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiSlave_isrTransmit(SpiSlave1Ptr);
 }

 void SpiSlaveRxISR(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiSlave_isrReceive(SpiSlave1Ptr);
 }

 void SpiSlaveErISR(void)
 {
     IfxCpu_enableInterrupts();
     IfxQspi_SpiSlave_isrError(SpiSlave1Ptr);
 }

void Spi_SlaveInit(IfxQspi_SpiSlave* SpiSlave,SpiSlavePins_t* SpiSlavePins, SpiChannelConfig* ChannelConfig)
{
  SpiSlave1Ptr = SpiSlave;
  // create module config
  IfxQspi_SpiSlave_Config spiSlaveConfig;
  IfxQspi_SpiSlave_initModuleConfig(&spiSlaveConfig, SpiSlavePins->SpiChipSelect->module);

  // set the maximum baudrate
  spiSlaveConfig.maximumBaudrate  = ChannelConfig->Baudrate;
  spiSlaveConfig.protocol.clockPolarity = ChannelConfig->ClockPolarity;
  spiSlaveConfig.protocol.dataHeading = ChannelConfig->DataHeading;

  // pin configuration
  const IfxQspi_SpiSlave_Pins slavePins = {
      SpiSlavePins->SpiClkIn, IfxPort_InputMode_pullDown,   // SCLK Pin
      SpiSlavePins->SpiMosi, IfxPort_InputMode_pullDown,   // MTSR Pin
      SpiSlavePins->SpiMiso, IfxPort_OutputMode_pushPull,  // MRST Pin
      SpiSlavePins->SpiChipSelect, IfxPort_InputMode_pullDown,   // SLSI Pin
      IfxPort_PadDriver_cmosAutomotiveSpeed2 // pad driver mode
  };
  spiSlaveConfig.pins = &slavePins;

  // ISR priorities and interrupt target
  spiSlaveConfig.txPriority       = ISR_PRIORITY_SPISLAVE_TX;
  spiSlaveConfig.rxPriority       = ISR_PRIORITY_SPISLAVE_RX;
  spiSlaveConfig.erPriority       = ISR_PRIORITY_SPISLAVE_ER;
  spiSlaveConfig.isrProvider      = IfxSrc_Tos_cpu0;

  //spiSlaveConfig.qspi->GLOBALCON.B.STIP = 1;
  // initialize module
  IfxQspi_SpiSlave_initModule(SpiSlave, &spiSlaveConfig);

}

void Spi_SlaveExchange(IfxQspi_SpiSlave* SpiSlave, uint8* SpiSlaveTx, uint8* SpiSlaveRx, uint16 size)
{
  for (uint8 i = 0; i < size; i++)
  {
    SpiTxBuffer[i] = SpiSlaveTx[i];
  }

  while( IfxQspi_SpiSlave_getStatus(SpiSlave) == IfxQspi_Status_busy );

  IfxQspi_SpiSlave_exchange(SpiSlave, &SpiTxBuffer[0], &SpiRxBuffer[0], size);

  while( IfxQspi_SpiSlave_getStatus(SpiSlave) == IfxQspi_Status_busy );

  for (uint8 i = 0; i< size; i++)
  {
    SpiSlaveRx[i] = SpiRxBuffer[i];
  }

}
